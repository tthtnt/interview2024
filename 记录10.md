## 实现一个 inherits 函数进行继承
在 JavaScript 中，可以通过原型链实现继承。下面是一个简单的 `inherits` 函数的实现，包括详细的代码注释和对原理的讲解。

```javascript
// 实现一个 inherits 函数
function inherits(Child, Parent) {
  // 创建一个空的构造函数，用于中转
  function Surrogate() {}
  // 将父类的原型对象赋值给中转构造函数的原型
  Surrogate.prototype = Parent.prototype;
  // 将子类的原型对象指向一个新的实例，该实例的原型为中转构造函数的实例
  Child.prototype = new Surrogate();
  // 将子类的构造函数指向自身
  Child.prototype.constructor = Child;
}

// 示例：定义一个父类
function Animal(name) {
  this.name = name;
}

// 在父类原型上定义方法
Animal.prototype.sayName = function() {
  console.log('My name is ' + this.name);
};

// 示例：定义一个子类
function Dog(name, breed) {
  // 在子类构造函数中调用父类构造函数，并传入必要的参数
  Animal.call(this, name);
  this.breed = breed;
}

// 继承父类
inherits(Dog, Animal);

// 在子类原型上定义方法
Dog.prototype.bark = function() {
  console.log('Woof!');
};

// 创建子类实例
const myDog = new Dog('Buddy', 'Golden Retriever');
myDog.sayName(); // 输出 'My name is Buddy'
myDog.bark(); // 输出 'Woof!'
```

### 代码注释和原理讲解

1. `inherits` 函数接受两个参数：`Child` 表示子类，`Parent` 表示父类。

2. 在 `inherits` 函数内部，首先创建一个空的构造函数 `Surrogate`。这个构造函数的作用是用于中转，不会被直接使用。

3. 然后，将父类的原型对象赋值给 `Surrogate` 构造函数的原型。这样，`Surrogate` 的实例就可以访问父类的方法和属性。

4. 接下来，将子类的原型对象指向一个新的实例，该实例的原型为 `Surrogate` 构造函数的实例。这样，子类的原型就可以继承父类的方法和属性。

5. 最后，将子类的构造函数指向自身，以确保构造函数的正确性。

通过以上步骤，我们实现了子类对父类的继承。在示例中，`Dog` 类成功继承了 `Animal` 类的属性和方法，同时也添加了自己的属性和方法。

这种继承方式基于原型链，通过原型链的连接，使得子类能够访问父类的属性和方法。这种继承方式是 JavaScript 中常见的继承实现方式之一。

## WeakMap 与垃圾回收有何关系
`WeakMap` 和垃圾回收之间有着密切的关系。在理解这种关系之前，让我们先简要介绍一下 `WeakMap`：

- `WeakMap` 是 ES6 中引入的一种数据结构，类似于 `Map`，但有一些重要的区别。
- `WeakMap` 的键只能是对象，而值可以是任意类型。
- `WeakMap` 中的键是弱引用，这意味着当键对象不再被引用时，它们可以被垃圾回收机制回收。

现在让我们来解释 `WeakMap` 和垃圾回收之间的关系：

1. **弱引用特性**：`WeakMap` 中的键是弱引用的，这意味着如果一个对象只有被 `WeakMap` 引用，而没有其他强引用指向它，那么这个对象就有可能被垃圾回收机制回收掉。

2. **避免内存泄漏**：使用 `WeakMap` 可以避免一些潜在的内存泄漏问题。如果你使用普通的 `Map`，当你不再需要某个键值对时，即使你删除了对键的引用，由于 `Map` 仍然持有对该键的引用，这个键对象就不会被垃圾回收。但是，如果你使用 `WeakMap`，当你不再持有对键的引用时，这个键对象会被垃圾回收机制回收。

3. **优化内存使用**：通过使用 `WeakMap`，可以更有效地管理内存，特别是在需要临时存储对象并且这些对象的生命周期与某些条件相关的情况下。一旦这些对象不再需要，它们就可以被垃圾回收，而不会占用不必要的内存空间。

总之，`WeakMap` 的弱引用特性使得它与垃圾回收机制结合使用可以更好地管理内存，避免内存泄漏，并优化内存使用。在开发中，特别是在处理临时数据或需要动态管理对象生命周期的情况下，`WeakMap` 可以是一个有用的工具。

## 什么是媒体查询，JS 可以监听媒体查询吗
媒体查询是一种用于在CSS中根据不同的媒体类型和特征来应用样式的技术。通过媒体查询，可以根据设备的特性（如屏幕宽度、高度、方向、分辨率等）来为不同的设备或不同的显示环境应用不同的样式。

在CSS中，媒体查询通常使用 `@media` 规则来实现。例如：

```css
/* 当屏幕宽度小于 600px 时应用这些样式 */
@media (max-width: 600px) {
  body {
    background-color: lightblue;
  }
}
```

这段代码表示在屏幕宽度小于 600px 时，将应用指定的背景颜色。

至于 JavaScript 是否可以直接监听媒体查询，答案是不可以。但是，JavaScript 可以通过监听窗口大小的变化来模拟对媒体查询的响应。你可以使用 `window.matchMedia` 方法来检查媒体查询的结果，并根据结果执行相应的操作。示例如下：

```javascript
// 检查屏幕宽度是否小于 600px
const mediaQuery = window.matchMedia('(max-width: 600px)');

// 添加一个监听器来响应媒体查询的变化
function handleMediaChange(event) {
  if (event.matches) {
    // 屏幕宽度小于 600px
    // 执行相应的操作
  } else {
    // 屏幕宽度大于等于 600px
    // 执行相应的操作
  }
}

// 添加监听器
mediaQuery.addListener(handleMediaChange);

// 页面加载时执行一次，以便根据初始状态执行相应的操作
handleMediaChange(mediaQuery);
```

在这个示例中，我们使用 `window.matchMedia` 方法来检查媒体查询的结果，并添加了一个监听器来响应媒体查询的变化。当媒体查询的结果发生变化时，会触发相应的操作。

通过这种方式，JavaScript 可以间接地响应媒体查询的变化，并根据不同的媒体查询结果执行相应的操作。

## 浏览器中事件有哪些属性与方法
在浏览器中，事件对象（例如由用户交互或代码触发的事件）具有许多属性和方法，用于访问有关事件的信息以及对事件进行操作。以下是一些常见的事件对象属性和方法：

### 事件对象的属性：

1. `type`：表示事件的类型，比如 "click"、"mouseover" 等。
2. `target`：表示触发事件的元素。
3. `currentTarget`：表示事件正在经过的元素，通常用于事件冒泡和事件捕获阶段。
4. `clientX` 和 `clientY`：表示事件发生时鼠标指针相对于浏览器窗口的水平和垂直坐标。
5. `keyCode` 和 `key`：表示键盘事件中按下的键的键码和键名。
6. `preventDefault()`：阻止事件的默认行为。
7. `stopPropagation()`：停止事件在DOM层次结构中的传播，阻止事件冒泡或捕获。

### 事件对象的方法：

1. `addEventListener(type, listener, useCapture)`：在元素上添加事件监听器。
2. `removeEventListener(type, listener, useCapture)`：从元素上移除事件监听器。
3. `dispatchEvent(event)`：手动触发一个特定类型的事件。

这些属性和方法只是事件对象中的一部分，实际上还有更多属性和方法可供使用，具体取决于事件的类型和浏览器的实现。通过使用这些属性和方法，可以对事件进行更精细的控制和处理。

## 如何逆序一个字符串
在 JavaScript 中，可以使用多种方法来逆序一个字符串。以下是几种常见的方法：

### 方法一：使用数组的 `reverse()` 方法和 `join()` 方法

```javascript
function reverseString(str) {
    return str.split('').reverse().join('');
}

// 示例
const originalString = "Hello, World!";
const reversedString = reverseString(originalString);
console.log(reversedString); // 输出： "!dlroW ,olleH"
```

### 方法二：使用循环逆序字符串

```javascript
function reverseString(str) {
    let reversed = '';
    for (let i = str.length - 1; i >= 0; i--) {
        reversed += str[i];
    }
    return reversed;
}

// 示例
const originalString = "Hello, World!";
const reversedString = reverseString(originalString);
console.log(reversedString); // 输出： "!dlroW ,olleH"
```

### 方法三：使用递归逆序字符串

```javascript
function reverseString(str) {
    if (str === '') {
        return '';
    } else {
        return reverseString(str.substr(1)) + str.charAt(0);
    }
}

// 示例
const originalString = "Hello, World!";
const reversedString = reverseString(originalString);
console.log(reversedString); // 输出： "!dlroW ,olleH"
```

这些方法都可以用来逆序一个字符串，具体选择哪种方法取决于个人偏好和性能要求。

## 如何正确得知某张图片的 MIME 格式
要正确确定某张图片的 MIME 类型（Multipurpose Internet Mail Extensions），可以使用几种方法：

### 方法一：HTTP 头信息

当浏览器请求图片时，服务器通常会在 HTTP 响应头中包含 `Content-Type` 头字段，指示了文件的 MIME 类型。你可以查看该响应头信息来获取图片的 MIME 类型。

### 方法二：文件扩展名

通常，文件的扩展名可以提供一些关于文件类型的线索。例如，`.jpg` 文件通常是 JPEG 图像，`.png` 文件通常是 PNG 图像。但这种方法并不总是可靠，因为文件可能被错误地命名。

### 方法三：使用 JavaScript

在前端，可以使用 JavaScript 来获取图片的 MIME 类型。一种方法是通过创建一个 `Blob` 对象，然后使用 `type` 属性来获取该对象的 MIME 类型。

```javascript
function getMimeType(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('HEAD', url, true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4 && xhr.status == 200) {
            var contentType = xhr.getResponseHeader('Content-Type');
            callback(contentType);
        }
    };
    xhr.send();
}

// 示例
var imageUrl = 'https://example.com/image.jpg';
getMimeType(imageUrl, function(mimeType) {
    console.log('MIME 类型：', mimeType);
});
```

### 方法四：使用第三方库

如果你在 Node.js 环境中，可以使用一些第三方库（如 `file-type`）来检测文件的 MIME 类型。这些库通常会分析文件的字节内容，然后返回相应的 MIME 类型。

综上所述，这些方法可以帮助你准确地确定某张图片的 MIME 类型。

## HTTP 响应头 cache-control: s-maxage=0 是什么意思
HTTP 响应头中的 `Cache-Control: s-maxage=0` 表示在代理服务器（如 CDN）中缓存的该资源的有效期为零秒。这意味着代理服务器不会缓存该资源，并且每次请求该资源时都会直接向源服务器发起请求。

`Cache-Control` 是一个常见的 HTTP 响应头字段，用于控制缓存的行为。在 `Cache-Control` 字段中，`s-maxage` 是一个特殊的指令，用于指定代理服务器缓存该资源的最大有效期。当 `s-maxage` 的值为 0 时，代理服务器将不会缓存该资源。

这个响应头的使用场景通常是在需要实时获取最新数据的情况下，确保每次请求都能从源服务器获取最新的资源。例如，当网站的内容频繁更新或个人用户的私人数据需要实时更新时，可以使用 `Cache-Control: s-maxage=0` 来禁用代理服务器的缓存，以确保用户获取到最新的数据。

需要注意的是，`Cache-Control: s-maxage=0` 只影响代理服务器的缓存行为，对于浏览器缓存没有直接影响。如果需要禁用浏览器缓存，可以使用其他的响应头字段，如 `Cache-Control: no-cache` 或 `Pragma: no-cache`。

## http 缓存控制中 Cach-Control 为 public 与 private 有何区别
在 HTTP 缓存控制中，`Cache-Control: public` 和 `Cache-Control: private` 有以下区别：

### Cache-Control: public
- 当响应中包含 `Cache-Control: public` 时，表示该响应可以被任何中间缓存（包括代理服务器）缓存。
- 这意味着即使响应是针对特定用户生成的，代理服务器也可以缓存该响应并将其提供给其他用户。
- 这通常用于公共资源，如 CSS 文件、JavaScript 文件或公共图片等，以便代理服务器可以缓存这些资源并在不同用户之间共享。

### Cache-Control: private
- 当响应中包含 `Cache-Control: private` 时，表示该响应只能被终端用户的浏览器缓存，而不能被代理服务器缓存。
- 这意味着响应是针对特定用户生成的，代理服务器不应该缓存该响应，以避免将用户的私人数据提供给其他用户。
- 这通常用于个人用户的私人数据，如用户登录后的页面内容或个性化的数据，以确保用户的隐私和安全。

总之，`Cache-Control: public` 用于允许代理服务器缓存响应并在不同用户之间共享，而 `Cache-Control: private` 用于限制响应只能被终端用户的浏览器缓存，以确保用户的隐私和安全。

## http 方法 get 与 post 有何区别
HTTP 协议定义了多种方法（也称为动词或谓词），其中最常见的是 GET 和 POST。它们之间的主要区别在于它们的作用和用法：

### GET 方法
1. **作用**：用于从服务器获取资源，通常用于请求数据。
2. **安全性**：GET 请求是“安全”的，即不会对服务器上的资源进行修改。它是幂等的，即多次重复的请求不会产生不同的影响。
3. **数据传输**：GET 请求的参数以 URL 查询字符串的形式发送，可以在 URL 中看到传递的参数。
4. **缓存**：GET 请求可以被浏览器缓存，可以被书签保存，并且可以被历史记录保存。

### POST 方法
1. **作用**：用于向服务器提交数据，通常用于提交表单数据或上传文件。
2. **安全性**：POST 请求对服务器上的资源进行修改，可能会有副作用。它不是幂等的，即多次重复的请求可能产生不同的影响。
3. **数据传输**：POST 请求的参数以请求体的形式发送，不会在 URL 中显示传递的参数。
4. **缓存**：POST 请求通常不会被浏览器缓存，不会被书签保存，也不会被历史记录保存。

### 其他区别
- **数据长度**：GET 请求对发送的数据长度有限制，因为数据是作为 URL 的一部分发送的，而 URL 的长度是有限制的；而 POST 请求对发送的数据长度没有特定的限制。
- **安全性**：由于 GET 请求的参数暴露在 URL 中，可能会因为浏览器历史记录、代理服务器日志等而引起安全问题；而 POST 请求的参数不会暴露在 URL 中，相对来说更安全。

综上所述，GET 方法用于获取资源，是安全的且幂等的，而 POST 方法用于提交数据，对服务器上的资源可能会有修改，不是幂等的。

## 箭头函数和普通函数的区别
JavaScript 中的箭头函数和普通函数有以下区别：

### 1. 箭头函数没有自己的 this 和 arguments
箭头函数没有自己的 `this` 值，它的 `this` 值继承自外层作用域的 `this` 值。这意味着在箭头函数中无法使用 `call()`、`apply()` 和 `bind()` 等方法来改变 `this` 的值。同样，箭头函数也没有自己的 `arguments` 对象，它继承自外层作用域的 `arguments` 对象。

### 2. 箭头函数不能用作构造函数
箭头函数没有自己的 `prototype` 对象，因此不能用 `new` 关键字来调用它们，或者将它们用作构造函数来创建对象。如果尝试使用 `new` 关键字调用箭头函数，会抛出一个 `TypeError` 异常。

### 3. 箭头函数不能使用 yield 关键字
箭头函数不能用作生成器函数，因此不能使用 `yield` 关键字来暂停和恢复函数执行。

### 4. 箭头函数语法更简洁
箭头函数的语法比普通函数更简洁，可以用更少的代码来实现相同的功能。例如，箭头函数可以省略 `function` 关键字和大括号，以及 `return` 关键字（如果函数体只有一条语句）。

以下是一个使用箭头函数和普通函数实现相同功能的示例：

```javascript
// 使用箭头函数
const add = (a, b) => a + b;

// 使用普通函数
function add(a, b) {
  return a + b;
}
```

综上所述，箭头函数和普通函数在语法和功能上有所不同，开发者可以根据需求选择使用哪种函数。

## 什么是 URL 编码 (URL Encode)
URL 编码（URL encoding）是将 URL 中的特殊字符转换为特定格式的编码方式，以便在网络传输中安全地传递和显示。URL 编码通常用于处理 URL 中的特殊字符，如空格、问号、井号、斜杠等，以确保这些字符不会破坏 URL 的结构或被误解为其他用途。

在 URL 编码中，特殊字符被替换为 `%` 后跟两位十六进制数表示的字符编码。例如，空格字符（ASCII 值为 32）在 URL 编码中会被替换为 `%20`。

### 示例：
- 空格字符编码：空格在 URL 编码中被替换为 `%20`。
- 问号字符编码：问号在 URL 编码中被替换为 `%3F`。
- 斜杠字符编码：斜杠在 URL 编码中被替换为 `%2F`。

### JavaScript 中的 URL 编码
在 JavaScript 中，可以使用 `encodeURIComponent()` 和 `encodeURI()` 方法进行 URL 编码：
- `encodeURIComponent()` 对整个 URL 进行编码，包括特殊字符，用于编码查询字符串参数。
- `encodeURI()` 用于对整个 URL 进行编码，但不会对特殊字符，如 `:/?#[]@` 进行编码。

### 示例：
```javascript
const url = 'https://www.example.com/search?q=hello world';
const encodedUrl = encodeURIComponent(url);
console.log(encodedUrl); // 输出：https%3A%2F%2Fwww.example.com%2Fsearch%3Fq%3Dhello%20world
```

通过 URL 编码，可以确保 URL 中的特殊字符被正确处理，从而避免因为特殊字符导致的 URL 解析错误或安全问题。

## http 状态码 204 使用在什么场景
HTTP 状态码 204 表示服务器成功处理了请求，但没有返回任何内容。这种状态通常在以下场景下使用：

1. **Ajax 请求**：当通过 Ajax 发起请求，服务器成功处理了请求，但不需要返回任何内容时，可以使用 204 状态码。这样客户端就知道请求已成功处理，但不需要更新页面内容。

2. **表单提交**：在某些情况下，表单提交后不需要返回新的页面内容，而只需要告知用户提交成功即可。这时可以返回 204 状态码。

3. **预检请求**：在 CORS（跨域资源共享）中，浏览器会发送一个预检请求（OPTIONS 请求）来检查实际请求是否安全。如果服务器成功处理了预检请求，但不需要返回任何内容，则可以使用 204 状态码。

4. **删除操作**：当客户端发送一个删除资源的请求，并且服务器成功删除了资源，但不需要返回任何内容时，可以使用 204 状态码。

总的来说，HTTP 状态码 204 用于表示服务器成功处理了请求，但没有需要返回的内容。这种状态码可以帮助客户端区分请求成功处理和有内容返回的情况，以便进行相应的处理。

## 使用 webpack 如何分包
Webpack 是一个现代 JavaScript 应用程序的静态模块打包工具，它可以将多个模块打包成一个或多个 bundle。分包可以帮助减小初始加载时间，提高应用性能。在 webpack 中，你可以使用动态 import、React.lazy 和 Suspense 等技术来进行代码分割。

1. **动态 import**：
   - 使用动态 import 可以按需加载模块，从而实现分包。在需要的地方使用 `import()` 函数动态导入模块，webpack 会将这些动态导入的模块单独打包成一个或多个文件。
   - 例如：
    ```javascript
    import("./moduleA").then(moduleA => {
      // 使用 moduleA
    });
    ```

2. **React.lazy 和 Suspense**（适用于 React 应用）：
   - 在 React 应用中，可以使用 React.lazy 和 Suspense 来实现组件级别的代码分割。React.lazy 允许你按需加载组件，而 Suspense 则可以在组件加载过程中显示加载指示器。
   - 例如：
    ```javascript
    const MyComponent = React.lazy(() => import('./MyComponent'));
    
    function MyComponentWrapper() {
      return (
        <React.Suspense fallback={<div>Loading...</div>}>
          <MyComponent />
        </React.Suspense>
      );
    }
    ```

3. **webpack 配置**：
   - 在 webpack 配置文件中，可以使用 `optimization.splitChunks` 来配置代码分割。这样 webpack 会自动将重复的模块抽取出来，形成单独的 chunk。
   - 例如：
    ```javascript
    module.exports = {
      //...
      optimization: {
        splitChunks: {
          chunks: 'all',
        },
      },
    };
    ```

通过以上方法，你可以在 webpack 中实现代码分割，将应用程序的代码按需分割成多个 bundle，从而提高应用性能并减小初始加载时间。

## 什么是 HSTS
HSTS（HTTP Strict Transport Security）是一种安全机制，它可以强制浏览器只使用 HTTPS 访问网站，从而提高网站的安全性和保护用户的隐私。HSTS 通过在服务器响应头中添加 `Strict-Transport-Security` 字段来实现。

当浏览器第一次访问支持 HSTS 的网站时，服务器会在响应头中添加 `Strict-Transport-Security` 字段，该字段包含一个指定的时间段，告诉浏览器只能使用 HTTPS 访问该网站。浏览器接收到响应后会将该时间段内所有对该网站的请求都强制使用 HTTPS，即使用户手动输入了 HTTP 地址也会被自动重定向到 HTTPS 地址。

HSTS 可以防止中间人攻击（如 SSLStrip 攻击），因为攻击者无法将 HTTPS 请求重定向到 HTTP 请求。此外，HSTS 还可以防止用户在不知情的情况下使用不安全的网络连接，从而提高用户的安全性和隐私保护。

需要注意的是，一旦启用 HSTS，所有的子域名都会受到影响，因此需要确保所有子域名都支持 HTTPS。如果某个子域名不支持 HTTPS，可以使用 `includeSubDomains` 标志来排除该子域名，如 `Strict-Transport-Security: max-age=31536000; includeSubDomains`。

总之，HSTS 是一种重要的安全机制，可以强制浏览器只使用 HTTPS 访问网站，从而提高网站的安全性和保护用户的隐私。

## http 中 referer 请求头是做什么的
HTTP 中的 Referer 请求头（拼写为 Referer 而非正确的英文单词 Referrer 是因为在 HTTP 标准中就是这样定义的）用于指示请求的来源页面的 URL。当用户从一个页面跳转到另一个页面时，浏览器会在请求头中包含 Referer 字段，告诉服务器用户是从哪个页面链接过来的。

Referer 请求头通常用于以下目的：

1. **统计分析**：网站可以利用 Referer 头来分析流量来源，了解用户是从哪个页面跳转过来的，从而进行流量统计和分析。

2. **防盗链**：网站可以根据 Referer 头来判断请求的来源，防止未经授权的站点使用其资源（如图片、视频等）。

3. **日志记录**：服务器可以记录 Referer 头，用于分析访问日志和行为分析。

需要注意的是，Referer 请求头可能会包含用户的敏感信息，因为它会泄露用户的浏览历史。因此，一些隐私保护措施可能会限制或修改 Referer 头的传递，比如一些浏览器或插件可能会在隐私模式下限制 Referer 头的发送。

总之，Referer 请求头用于指示请求的来源页面的 URL，可以用于统计分析、防盗链和日志记录等用途。

## React 中什么是合成事件
在 React 中，合成事件（Synthetic Event）是一种封装了原生浏览器事件的跨浏览器包装器。React 使用合成事件来提供一致的跨浏览器事件处理方式，并且在事件处理中提供了额外的功能和性能优化。

React 使用合成事件的主要目的是提供一种统一的事件处理机制，使开发者不必担心不同浏览器之间事件的兼容性问题。合成事件对象是由 React 创建的，它封装了底层浏览器的原生事件，并提供了与原生事件相似的接口。

合成事件对象包含了与原生事件相似的属性和方法，如 `preventDefault()`、`stopPropagation()` 等，同时还包含一些额外的特性，比如事件委托、事件池等，以提高性能和减少内存占用。

使用合成事件的好处包括：

1. **跨浏览器兼容性**：无需担心不同浏览器之间的事件兼容性问题，React 提供了一致的事件处理方式。

2. **性能优化**：React 使用事件委托和事件池等技术来优化事件处理的性能，减少内存占用。

3. **事件委托**：React 通过事件委托将事件处理委托给父元素，减少了事件处理器的数量，提高了性能。

在 React 中，你可以通过将事件处理函数传递给组件的 props 来处理合成事件。例如，在 JSX 中，你可以这样使用：

```jsx
<button onClick={handleClick}>Click me</button>
```

在这个例子中，`onClick` 是一个合成事件，当用户点击按钮时，React 会创建一个合成事件对象，并调用 `handleClick` 函数来处理该事件。

总之，合成事件是 React 提供的一种跨浏览器的事件处理机制，它封装了原生浏览器事件，并提供了额外的功能和性能优化。

## 什么是纯函数
在计算机科学中，纯函数（Pure Function）是指对于给定的输入，总是返回相同的输出，且没有任何副作用（Side Effect）。纯函数不会修改传入的参数，也不会修改全局变量或引用传递的变量，而是通过返回值来传递计算结果。

纯函数具有以下特点：

1. **输入决定输出**：对于相同的输入，纯函数总是返回相同的输出，不会受到外部环境的影响。

2. **没有副作用**：纯函数不会修改传入的参数，也不会修改全局变量或引用传递的变量，而是通过返回值来传递计算结果。

由于纯函数不会产生副作用，因此它们具有以下优点：

1. **可缓存性**：由于纯函数总是返回相同的输出，因此可以缓存函数的结果，提高函数的性能。

2. **可测试性**：由于纯函数不会受到外部环境的影响，因此可以轻松地编写测试用例，确保函数的正确性。

3. **可组合性**：由于纯函数不会产生副作用，因此可以轻松地将多个函数组合在一起，形成更复杂的函数。

在函数式编程中，纯函数是非常重要的概念，它们可以帮助我们编写可靠、高效、可维护的代码。在 JavaScript 中，许多内置函数和库函数都是纯函数，如 `slice()`、`concat()`、`map()`、`filter()` 等。

总之，纯函数是指对于给定的输入，总是返回相同的输出，且没有任何副作用。纯函数具有可缓存性、可测试性和可组合性等优点，是函数式编程中非常重要的概念。

## React/Vue 中受控组件与不受控组件的区别
在 React 和 Vue 中，组件可以分为受控组件和不受控组件，它们的区别在于如何管理组件内部数据的更新和同步。

**受控组件**

受控组件是指组件内部的数据状态由父组件直接管理。

* **数据绑定**：组件内部的数据通过 props 从父组件传递过来，而组件的输入值通过 `onChange` 事件更新父组件的状态。
* **优点**：
    * 数据状态清晰，易于管理。
    * 可以更好地控制数据流向。
    * 更容易进行单元测试。
* **缺点**：
    * 代码可能显得更加复杂，需要更多状态管理逻辑。

**不受控组件**

不受控组件是指组件内部的数据状态由 DOM 元素直接管理。

* **数据绑定**：组件通过 `ref` 或 `value` 属性绑定到 DOM 元素上，而组件的输入值由 DOM 元素本身决定。
* **优点**：
    * 代码简洁，易于理解。
    * 更适合处理简单的表单元素。
* **缺点**：
    * 数据状态管理较为复杂，需要手动维护。
    * 难以进行单元测试。

**举个例子**

假设我们有一个简单的文本输入框组件，用受控和不受控两种方式实现：

**受控组件**

```jsx
functionInput({ value, onChange }) {
  return <input type="text" value={value} onChange={onChange} />;
}
```

**不受控组件**

```jsx
function UncontrolledInput() {
  const inputRef = useRef(null);
  return <input type="text" ref={inputRef} />;
}
```

**总结**

选择受控还是不受控组件取决于具体场景的需求。

* 如果需要更好地控制数据状态和流向，或者需要进行单元测试，建议使用受控组件。

* 如果只需要简单的表单元素，或者代码简洁性更重要，不受控组件。

## 给数字添加千位符
在 JavaScript 中，你可以使用内置的方法来给数字添加千位符。一种常见的方法是使用 `toLocaleString()` 方法，它可以将数字格式化为带有千位符的字符串表示。

例如，假设你有一个数字 `1234567.89`，你可以这样将其格式化为带有千位符的字符串：

```javascript
const number = 1234567.89;
const formattedNumber = number.toLocaleString(); // "1,234,567.89"
```

`toLocaleString()` 方法默认使用用户的本地化设置来格式化数字，因此千位符的显示格式可能因用户的地区而异。

如果你希望强制使用特定的语言环境来格式化数字，可以传递相应的语言环境参数给 `toLocaleString()` 方法，例如：

```javascript
const number = 1234567.89;
const formattedNumber = number.toLocaleString('en-US'); // "1,234,567.89"
```

以上代码将会使用美国的语言环境来格式化数字，确保千位符的显示符合美国的习惯。

通过使用 `toLocaleString()` 方法，你可以方便地给数字添加千位符，使其更易读和美观。

## React 中监听 input 的 onChange 事件的原生事件是什么
在 React 中，你可以监听 `<input>` 元素的 `onChange` 事件来响应用户输入的变化。在 React 中，`onChange` 事件对应的原生事件是 `input` 事件。

下面是一个简单的示例，演示了如何在 React 中监听 `<input>` 元素的 `onChange` 事件：

```jsx
import React, { useState } from 'react';

function MyInputComponent() {
  const [inputValue, setInputValue] = useState('');

  const handleInputChange = (event) => {
    setInputValue(event.target.value);
  };

  return (
    <input
      type="text"
      value={inputValue}
      onChange={handleInputChange}
    />
  );
}

export default MyInputComponent;
```

在这个示例中，`handleInputChange` 函数会在用户输入时被调用，它接收一个事件对象作为参数。通过 `event.target.value`，我们可以获取用户输入的值，并将其更新到组件的状态中（这里使用了 `useState` 钩子来管理输入框的值）。

当用户在输入框中输入内容时，`onChange` 事件会触发，调用 `handleInputChange` 函数，从而更新输入框的值并实时反映在界面上。

## 在浏览器中点击 a 标签保存为文件如何做
在浏览器中点击 `<a>` 标签来保存文件，通常会使用如下的方法：

1. 首先，你需要创建一个 `<a>` 标签，并设置它的 `href` 属性为文件的 URL，同时设置 `download` 属性为文件的名称。

2. 然后，通过 JavaScript 触发这个 `<a>` 标签的点击事件，这样浏览器就会开始下载这个文件。

下面是一个示例，演示了如何通过点击 `<a>` 标签来保存文件：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Download File Example</title>
</head>
<body>
  <a id="downloadLink" style="display:none;"></a>

  <button onclick="downloadFile()">Download File</button>

  <script>
    function downloadFile() {
      const fileContent = 'This is the content of the file.';
      const fileName = 'example.txt';
      const file = new Blob([fileContent], { type: 'text/plain' });
      const url = URL.createObjectURL(file);

      const downloadLink = document.getElementById('downloadLink');
      downloadLink.href = url;
      downloadLink.download = fileName;
      downloadLink.click();

      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
```

在这个示例中，当用户点击 "Download File" 按钮时，`downloadFile()` 函数会被调用。这个函数会创建一个包含文件内容的 Blob 对象，并将其转换为 URL，然后设置 `<a>` 标签的 `href` 和 `download` 属性，最后模拟点击 `<a>` 标签来触发文件下载。下载完成后，使用 `URL.revokeObjectURL(url)` 来释放 URL 对象。

你可以根据需要修改文件内容、文件类型和文件名来适应你的实际需求。

## 引入 BFF 层的优势在哪里
引入 BFF（Backend For Frontend）层的主要优势在于它可以提供以下几个方面的好处：

1. **定制化前端体验**：BFF 允许前端团队根据特定的用户界面需求来定制 API 调用，以最大程度地优化前端性能和用户体验。这意味着前端团队可以针对特定页面或组件的需求，创建专门的 API 端点，而不必受到通用性和后端 API 结构的限制。

2. **减少前后端通信次数**：BFF 可以将多个后端服务的数据聚合为一个 API 端点，从而减少前端与后端之间的通信次数。这有助于降低网络延迟，提高页面加载速度，并减轻后端服务的负担。

3. **安全性和隔离**：BFF 可以作为一个安全层，处理所有与后端的通信，从而减少了前端直接与后端通信的风险。它可以在前端和后端之间建立一道额外的隔离层，有助于保护后端服务免受一些常见的安全威胁。

4. **跨平台兼容性**：BFF 层可以根据不同的前端平台（Web、移动端、桌面应用等）提供定制化的数据和逻辑，以满足不同平台的需求。

5. **简化前端开发**：通过将数据聚合和转换逻辑放在 BFF 层处理，前端开发人员可以专注于构建用户界面和用户体验，而不必过多关注数据获取和处理的细节。

总的来说，BFF 层可以帮助组织更好地管理前后端之间的通信和数据流，提高前端性能和安全性，并为不同的前端平台提供定制化的数据和逻辑支持。

## Object.is 与全等运算符(===)有何区别
`Object.is` 方法和全等运算符（`===`）都用于比较两个值是否相等，但它们在某些情况下有所不同。

主要区别如下：

1. **处理特殊值的方式不同**：全等运算符在比较时，遵循 JavaScript 的相等性规则，对于特殊值（NaN、+0、-0），有时会产生一些奇特的结果。而 `Object.is` 方法在比较时，对于这些特殊值有更准确的处理方式。例如，`Object.is(NaN, NaN)` 返回 `true`，而 `NaN === NaN` 返回 `false`。

2. **处理零值的方式不同**：全等运算符将 +0 和 -0 视为相等，即 `+0 === -0` 返回 `true`。而 `Object.is` 方法将 +0 和 -0 视为不相等，即 `Object.is(+0, -0)` 返回 `false`。

3. **性能方面的差异**：一般情况下，全等运算符的性能更好，因为它是 JavaScript 的内置运算符，而 `Object.is` 方法需要调用一个函数来执行比较。

综上所述，`Object.is` 方法提供了一种更准确和严格的相等比较方式，特别是对于特殊值和零值的处理。但在大多数情况下，全等运算符（`===`）是更常用和更高效的比较方式。你可以根据具体的需求选择使用哪种方式。

## 在 React hooks 中如何模拟 forceUpdate
在 React hooks 中，可以使用 `useState` 钩子来模拟类组件中的 `forceUpdate` 方法。`forceUpdate` 方法用于强制组件重新渲染，而在函数式组件中，由于没有实例，因此没有类似的方法。

你可以通过创建一个状态来模拟 `forceUpdate` 的效果。当需要强制组件重新渲染时，更新这个状态的值，从而触发组件的重新渲染。

以下是一个示例，演示了如何在 React hooks 中模拟 `forceUpdate`：

```jsx
import React, { useState } from 'react';

function MyComponent() {
  const [, forceUpdate] = useState();

  const handleForceUpdate = () => {
    forceUpdate(Math.random()); // 更新状态，强制组件重新渲染
  };

  return (
    <div>
      <button onClick={handleForceUpdate}>Force Update</button>
      <p>Component content</p>
    </div>
  );
}

export default MyComponent;
```

在这个示例中，我们使用 `useState` 创建了一个不使用的状态变量。`forceUpdate` 函数实际上是一个更新状态的函数，但我们并不使用这个状态的值，而是传递一个新的随机值来触发组件的重新渲染。当用户点击按钮时，调用 `handleForceUpdate` 函数，它会调用 `forceUpdate` 函数并传递一个新的随机值，从而强制组件重新渲染。

需要注意的是，这种模拟 `forceUpdate` 的方式并不是官方推荐的做法，因为它绕过了 React 的渲染机制。在大多数情况下，使用状态和属性的变化来驱动组件的重新渲染是更好的做法。但是，如果确实有需要强制组件重新渲染的情况，这种方式可以实现类似的效果。

## 如何把对象转化为 key/value 的二维数组
将对象转换为 key/value 的二维数组可以使用 `Object.entries()` 方法。这个方法返回一个由对象的键值对组成的数组，其中每个键值对都表示为一个二元数组，第一个元素是键，第二个元素是值。

以下是一个示例，演示了如何使用 `Object.entries()` 方法将对象转换为 key/value 的二维数组：

```javascript
const obj = { a: 1, b: 2, c: 3 };

const arr = Object.entries(obj);

console.log(arr);
// 输出：[ [ 'a', 1 ], [ 'b', 2 ], [ 'c', 3 ] ]
```

在这个示例中，我们首先定义了一个对象 `obj`，它包含三个属性。然后，我们使用 `Object.entries()` 方法将这个对象转换为一个由键值对组成的二维数组 `arr`。最后，我们将这个数组输出到控制台。

需要注意的是，`Object.entries()` 方法是 ES2017 引入的新方法，如果你的代码需要支持旧版本的浏览器或 Node.js，你可能需要使用 polyfill 或其他的兼容性解决方案。

## 在 JS 中如何监听 Object 某个属性值的变化
如果你想在 JavaScript 中监听对象属性的变化，一种常见的做法是使用 ES6 中的 Proxy 对象。通过使用 Proxy，你可以拦截并定义基本操作的自定义行为，包括属性的读取、赋值、删除等操作。

以下是一个简单的示例，演示如何使用 Proxy 监听对象属性的变化：

```javascript
let target = {
  name: 'Alice',
  age: 30
};

let handler = {
  set: function(target, key, value) {
    console.log(`Setting ${key} to ${value}`);
    target[key] = value;
  }
};

let proxy = new Proxy(target, handler);

proxy.name = 'Bob'; // 设置属性值时触发 set 操作
console.log(proxy.name); // 输出：Bob
```

在这个示例中，我们首先创建了一个普通的对象 `target`，然后定义了一个 `handler` 对象，其中包含了一个 `set` 方法，用于拦截属性的赋值操作。接着，我们使用 Proxy 创建了一个代理对象 `proxy`，这个代理对象会拦截对 `target` 对象的操作。

当我们通过代理对象 `proxy` 修改属性值时，`set` 方法会被触发，从而实现对属性变化的监听和自定义操作。

需要注意的是，Proxy 是 ES6 中新增的特性，如果你需要兼容较老的浏览器，可能需要使用 polyfill 或其他解决方案。

除了上述方法，还可以使用 `Object.defineProperty()` 方法来监听对象属性的变化。这个方法可以用来修改对象属性的描述符，包括 `value`、`writable`、`enumerable` 和 `configurable` 等属性。其中，`get` 和 `set` 属性可以用来监听属性的读取和赋值操作。

以下是一个简单的示例，演示如何使用 `Object.defineProperty()` 方法监听对象属性的变化：

```javascript
let obj = {
  name: 'Alice',
  age: 30
};

Object.defineProperty(obj, 'name', {
  get: function() {
    console.log('Getting name');
    return this._name;
  },
  set: function(value) {
    console.log(`Setting name to ${value}`);
    this._name = value;
  }
});

obj.name = 'Bob'; // 设置属性值时触发 set 操作
console.log(obj.name); // 获取属性值时触发 get 操作
```

在这个示例中，我们使用 `Object.defineProperty()` 方法为 `obj` 对象的 `name` 属性添加了一个 `get` 和 `set` 方法，用于监听属性的读取和赋值操作。当我们通过 `obj.name` 获取或设置属性值时，相应的回调函数会被触发。

需要注意的是，`Object.defineProperty()` 方法只能用来监听已有的属性，如果需要监听新添加的属性，可以使用 `Object.defineProperties()` 方法。此外，这种方法需要对每个属性都进行单独的设置，比较繁琐，不太适用于大规模的对象属性监听。

## js 中什么是 AsyncIterable
在 JavaScript 中，AsyncIterable 是指实现了异步迭代器协议的对象。异步迭代器协议是 ES2018 引入的一种迭代器协议，它允许对象以异步的方式进行迭代操作。

AsyncIterable 对象可以被用于异步迭代，这意味着它可以在迭代过程中异步地产生值。这在处理异步数据流或者需要异步操作的迭代场景中非常有用。

异步迭代器协议要求对象实现一个名为 `[Symbol.asyncIterator]` 的方法，该方法返回一个异步迭代器对象。异步迭代器对象本身需要实现一个名为 `next` 的异步方法，用于产生迭代结果。

以下是一个简单的示例，演示了如何创建一个 AsyncIterable 对象：

```javascript
const asyncIterableObject = {
  async *[Symbol.asyncIterator]() {
    for (let i = 0; i < 5; i++) {
      await new Promise(resolve => setTimeout(resolve, 1000)); // 模拟异步操作
      yield i;
    }
  }
};

(async function() {
  for await (const value of asyncIterableObject) {
    console.log(value); // 每隔一秒输出一个值，0 到 4
  }
})();
```

在这个示例中，我们创建了一个对象 `asyncIterableObject`，并通过实现 `[Symbol.asyncIterator]` 方法来使其成为一个 AsyncIterable 对象。在 `async *[Symbol.asyncIterator]()` 方法中，我们使用 `yield` 关键字产生了一系列的值，并通过 `await` 关键字模拟了异步操作。最后，我们使用 `for await...of` 循环来异步地迭代该对象，并输出每个值。

AsyncIterable 对象在处理异步数据流、处理异步操作的迭代以及与异步函数和事件循环交互等场景中非常有用。

## 请简述重新登录 refresh token 的原理
重新登录时，使用 refresh token 的原理通常涉及以下步骤：

1. **获取 Refresh Token**：在用户首次登录成功后，服务器会返回两个重要的令牌：访问令牌（Access Token）和刷新令牌（Refresh Token）。刷新令牌通常具有更长的有效期，用于获取新的访问令牌。

2. **访问令牌过期**：在用户使用访问令牌进行请求时，服务器会验证访问令牌的有效性和过期时间。如果访问令牌过期，服务器会返回一个特定的错误代码，指示客户端需要使用刷新令牌来获取新的访问令牌。

3. **使用 Refresh Token 获取新的 Access Token**：客户端收到访问令牌过期的错误后，会使用保存的刷新令牌向服务器发送请求，请求新的访问令牌。

4. **服务器验证 Refresh Token**：服务器接收到包含刷新令牌的请求后，会验证刷新令牌的有效性和权限。如果刷新令牌有效且权限允许，服务器会颁发一个新的访问令牌，并返回给客户端。

5. **使用新的 Access Token 发起请求**：客户端收到新的访问令牌后，可以使用它来发起新的请求，并继续访问受保护的资源。

这个过程中，刷新令牌的安全性至关重要。因为刷新令牌通常具有更长的有效期，它需要得到妥善的保护，以防止被恶意获取。另外，服务器也需要对刷新令牌的有效性进行严格的验证，以确保安全性。

总的来说，使用刷新令牌的原理是在访问令牌过期时，通过刷新令牌向服务器获取新的访问令牌，从而实现持续的用户会话和安全的访问控制。

## 详细描述一下JSBridge
JSBridge 是一个用于连接 Web 页和 Native 应用的桥梁，它允许 代码在 Web 页中调用 Native 端的 API，反之亦然。

**工作原理:**

JSBridge 的核心是通过消息传递机制来实现通信的。

1. **Web 端发送消息:**

   - Web 页面的 代码通过 JSBridge 的 API 发送消息到 Native 端。

2. **Native 端接收消息:**

   - Native 端会监听来自 Web 页面的消息，并根据消息内容执行相应的操作。

3. **Native 端返回结果:**

   - Native 端处理完消息后，会通过 JSBridge 的 API 将结果发送回 Web 端。

4. **Web 端接收结果:**

   - Web 端接收到 Native 端返回的结果后，可以根据结果进行相应的处理。

**优势:**

* **跨平台兼容性:** JSBridge 可以用于连接不同平台的 Native 应用和 Web 页面，例如 iOS、Android 和 Windows。
* **简化开发:** JSBridge 可以简化 Native 应用和 Web 页面的交互开发，避免了编写大量 Native 代码来处理 Web 页面请求。
* **灵活性和扩展性:** JSBridge 可以根据需要定制消息格式和通信协议，方便开发者根据实际需求进行扩展和定制。

**常见应用场景:**

* **调用 Native 功能:**

   - Web 页面可以调用 Native 端的摄像头、麦克风、定位、地图等功能。

* **数据交互:**

   - Web 页面可以向 Native 端发送数据，例如用户输入的信息，并接收 Native 端返回的数据，例如用户位置信息。
* **分享功能:**

   - Web 页面可以利用 JSBridge 调用 Native 端的分享功能，方便用户分享网页内容到社交平台。

**实现方式:**

JSBridge 的实现方式有很多种，例如：

* **WebView 的Bridge:**

   - 许多 Native 开发框架都内置了 WebView 的Bridge，例如 Android 的 WebView 和 iOS 的 WKWebView。

* **第三方库:**

   - 有一些开源的 JSBridge 库，例如 Cordova、PhoneGap 和 React Native 的桥接方案。

**的事项:**

* **安全性:** 在使用 JSBridge 时，需要注意安全性问题，避免 Web 页面发送敏感数据到 Native 端。

* **性能:** JSBridge 的通信需要跨平台进行，可能会带来一定的性能损耗。

* **兼容性:** 不同的 JSBridge 实现方式可能存在兼容性问题，需要根据实际情况选择合适的方案。

## React/Vue 中兄弟组件如何进行通信
在React和Vue中，兄弟组件之间进行通信通常需要通过共同的父组件或者通过状态管理工具来实现。下面分别介绍React和Vue中兄弟组件通信的方法：

### React中兄弟组件通信的方法：

1. **通过共同的父组件传递props：**
   - 父组件可以将需要共享的数据作为props传递给兄弟组件，实现兄弟组件之间的通信。

2. **使用Context API：**
   - React的Context API可以在组件树中提供全局的数据共享，允许兄弟组件直接访问共享的数据。

3. **通过事件总线或全局事件：**
   - 可以使用事件总线或全局事件来触发和监听事件，实现兄弟组件之间的通信。

4. **使用第三方状态管理工具（如Redux、MobX）：**
   - 可以使用Redux、MobX等状态管理工具来管理应用的状态，兄弟组件可以通过这些工具共享状态。

### Vue中兄弟组件通信的方法：

1. **通过共同的父组件传递props：**
   - 和React类似，父组件可以通过props将数据传递给兄弟组件。

2. **使用事件总线（$emit / $on）：**
   - Vue实例可以作为事件总线，兄弟组件可以通过$emit触发事件，通过$on监听事件来实现通信。

3. **使用Vuex状态管理：**
   - Vuex是Vue的官方状态管理库，可以用于管理应用的状态，兄弟组件可以通过Vuex共享状态。

4. **通过provide / inject：**
   - 父组件可以使用provide提供数据，子组件可以使用inject注入数据，实现兄弟组件之间的通信。

总的来说，无论是在React还是Vue中，兄弟组件之间的通信都可以通过共同的父组件传递props、使用全局状态管理工具、使用事件总线等方式来实现。具体选择哪种方式取决于项目的需求和复杂度。

## React.memo 中是如何实现性能优化的
`React.memo` 是 React 提供的一个函数，用于对函数组件进行性能优化，避免不必要的渲染。当组件的 props 没有改变时，`React.memo` 可以帮助组件避免重新渲染，从而提高性能。

具体来说，`React.memo` 实现性能优化的方式如下：

1. **浅比较 props：**
   - `React.memo` 对组件接收的 props 进行浅比较（shallow comparison），只有当 props 发生变化时，组件才会重新渲染。如果两次渲染时传递给组件的 props 是相同的（即浅比较相等），组件将不会重新渲染。

2. **使用缓存：**
   - `React.memo` 使用缓存机制来存储前一次渲染时的组件实例，以及 props 和渲染结果。当组件重新渲染时，会先检查新的 props 是否和之前的 props 相同，如果相同，直接返回缓存的渲染结果，避免不必要的计算和渲染。

3. **减少不必要的渲染：**
   - 在函数组件的重新渲染过程中，`React.memo` 可以帮助组件避免不必要的渲染，提高性能。这对于那些接收大量不变数据的组件尤其有用。

使用 `React.memo` 可以在某些情况下显著提高 React 应用的性能，特别是在具有大量子组件的列表或复杂组件树中。然而，需要注意的是，并非所有组件都适合使用 `React.memo`，因为对 props 进行比较也会带来一定的开销。在实际开发中，需要根据具体情况权衡是否使用 `React.memo` 进行性能优化。

## 如何使用 JS 实现一个发布订阅模式
```javascript
class {
  () {
    this.events = {};
  }

  // 订阅事件
  on(eventName, listener) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(listener);
  }

  // 取消订阅事件
  off(eventName, listener) {
    if (this.events[eventName]) {
      this.events[eventName] = this.events[eventName].filter(
        (l) => l !== listener
      );
    }
  }

  // 发布事件
  emit(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].forEach((listener) => {
        listener(...args);
      });
    }
  }
}

// 使用示例
const eventEmitter = new();

// 订阅事件 'message'
eventEmitter.on('message', (data) => {
  console.log('Received message:', data);
});

// 发布事件 'message'
eventEmitter.emit('message', 'Hello, world!'); 

// 取消订阅事件 'message'
eventEmitter.off('message', (data) => {
  console.log('Received message:', data);
});

// 发布事件 'message' 不会触发任何回调
eventEmitter.emit('message', 'Another message'); 
```

**解释:**

* ** 类:** 实现了发布订阅模式的核心逻辑。
* **`on(eventName, listener)`:** 订阅特定事件（`eventName`）。当事件被发布时，注册的监听器（`listener`）会被调用。
* **`off(eventName, listener)`:** 取消订阅特定事件的监听器。
* **`emit(eventName, ...args)`:** 发布特定事件，并传递可选参数（`args`）。

**:**

1. 创建一个 `` 实例。
2. 使用 `on` 方法订阅事件，注册监听器函数。
3. 使用 `emit` 方法发布事件，传递可选参数。
4. 监听器函数将在事件被发布时被调用，接收事件参数。
5. 使用 `off` 方法取消订阅特定事件的监听器。

**优点:**

* 简洁易用：代码结构清晰，易于理解和维护。
* 解耦：发布者和订阅者之间没有直接关系，提高了代码的模块化和可扩展性。
* 可扩展性：可以订阅多个事件，并为每个事件注册多个监听器。

**注意:**

* 为了避免内存泄漏，在取消订阅事件时，应该使用 `off` 方法清除监听器。

## immer 的原理是什么，为什么它的性能更高
Immer 是一个用于管理不可变数据的 JavaScript 库，它可以帮助开发者以一种更直观、更易于理解的方式来处理不可变数据。Immer 的原理和性能优化主要基于以下几个方面：

### 原理：

1. **结构共享：**
   - Immer 使用结构共享（structural sharing）的方式来实现不可变数据。当进行数据修改时，Immer 会复制被修改的部分，而保持其他部分的引用不变，从而最大程度地减少内存占用和提高性能。

2. **代理对象：**
   - Immer 使用代理对象（Proxies）来对原始数据进行包装，以便在修改数据时能够捕获对数据的访问和修改操作。这使得在修改数据时，Immer 能够跟踪修改，并在必要时进行结构共享，而无需创建完全新的数据副本。

3. **函数式更新：**
   - Immer 支持使用函数式更新的方式来修改数据，这种方式更加直观和易于理解。通过提供一个函数，开发者可以在函数内部修改数据，而不需要手动创建深层次的不可变副本。

### 性能优化：

1. **延迟复制：**
   - Immer 采用延迟复制的策略，在数据被修改之后，并不立即进行深层次的复制，而是在需要时才进行复制。这样可以避免不必要的复制操作，提高性能。

2. **局部更新：**
   - 结构共享的特性使得 Immer 在进行数据修改时，只需要更新被修改的部分，而不需要对整个数据结构进行复制。这样可以减少内存占用和提高性能。

3. **优化的数据访问：**
   - 通过代理对象，Immer 可以捕获对数据的访问和修改操作，从而能够更加智能地进行数据更新，避免不必要的操作，提高性能。

总的来说，Immer 通过结构共享、延迟复制和代理对象等技术手段，以及提供直观的函数式更新方式，使得在处理不可变数据时性能更高，同时提供了更好的开发体验和易用性。

## React.useMemo 与 React.useCallback 是如何进行性能优化的
`React.useMemo` 和 `React.useCallback` 都是 React 提供的用于性能优化的 Hook。它们的作用类似，都是为了避免不必要的计算和渲染，但它们分别用于不同的场景。

### React.useMemo：

`React.useMemo` 用于在渲染过程中对值进行记忆（memoization），当依赖的数据发生变化时，才重新计算值。它的性能优化体现在以下几个方面：

1. **避免不必要的计算：**
   - `React.useMemo` 可以缓存计算结果，只有在依赖的数据发生变化时才重新计算。这样可以避免在每次渲染时都进行重复的计算，提高性能。

2. **优化渲染过程：**
   - 通过缓存计算结果，`React.useMemo` 可以确保只有在依赖项变化时才会重新计算值。这有助于优化渲染过程，避免不必要的重新渲染。

### React.useCallback：

`React.useCallback` 用于缓存回调函数，当依赖的数据发生变化时，才会返回新的回调函数。它的性能优化体现在以下几个方面：

1. **避免不必要的回调创建：**
   - `React.useCallback` 可以缓存回调函数，只有在依赖的数据发生变化时才会返回新的回调函数。这样可以避免在每次渲染时都创建新的回调函数，提高性能。

2. **优化子组件性能：**
   - 将缓存的回调函数传递给子组件时，可以避免在每次渲染时都重新创建回调函数，从而优化子组件的性能。

### 总结：

`React.useMemo` 和 `React.useCallback` 都是用于避免不必要的计算和创建，从而提高组件的性能。`useMemo` 用于缓存计算结果，而 `useCallback` 用于缓存回调函数。它们都在依赖项发生变化时才会重新计算或返回新的值，从而避免不必要的渲染和创建操作，提高了 React 组件的性能。

## 什么是 base64 与 URL Safe base64
Base64 是一种用于将二进制数据编码为 ASCII 字符串的编码方式。它的目的是在不可靠的传输媒体中安全地传输数据，或将数据存储在文本格式中，例如在电子邮件中传输二进制附件或在网页中嵌入图像。

Base64 编码使用 64 个字符来表示二进制数据的 6 位，通常使用以下字符集：A-Z、a-z、0-9 和两个特殊字符 "+", "/"。编码过程将每三个字节的数据（24 位）划分为四个 6 位的组，然后将每个 6 位的组映射到相应的字符。如果数据长度不是三的倍数，会使用填充字符 "=" 来补齐。

例如，字符串 "Hello" 的 Base64 编码为 "SGVsbG8="。

URL Safe Base64 是对 Base64 编码的一种变种，它将 Base64 编码中的两个特殊字符 "+", "/" 替换为 URL 安全的字符 "-" 和 "_"，以避免在 URL 中引起歧义或被误解。这样可以确保 Base64 编码后的字符串可以安全地用作 URL 的一部分，而无需进行额外的编码或解码。

例如，字符串 "Hello" 的 URL Safe Base64 编码为 "SGVsbG8="，与标准 Base64 编码相同。

总结：Base64 是一种将二进制数据编码为 ASCII 字符串的方式，常用于在不可靠的传输媒体中安全地传输数据。URL Safe Base64 是对 Base64 编码的一种变种，将特殊字符替换为 URL 安全的字符，以便在 URL 中使用。

## 列举 Number、String、Array、Object、Promise 有哪些 API
以下是 Number、String、Array、Object、Promise 常用的 API：

### Number：

- `Number.isNaN()`: 判断一个值是否为 NaN。
- `Number.parseInt()`: 将字符串转换为整数。
- `Number.parseFloat()`: 将字符串转换为浮点数。
- `Number.isInteger()`: 判断一个值是否为整数。
- `Number.MAX_SAFE_INTEGER`: JavaScript 中的最大安全整数。
- `Number.MIN_SAFE_INTEGER`: JavaScript 中的最小安全整数。

### String：

- `String.length`: 返回字符串的长度。
- `String.charAt()`: 返回字符串中指定位置的字符。
- `String.indexOf()`: 返回字符串中第一个匹配的子字符串的位置。
- `String.lastIndexOf()`: 返回字符串中最后一个匹配的子字符串的位置。
- `String.slice()`: 提取字符串的一部分。
- `String.split()`: 将字符串分割为子字符串数组。
- `String.toLowerCase()`: 将字符串转换为小写。
- `String.toUpperCase()`: 将字符串转换为大写。

### Array：

- `Array.length`: 返回数组的长度。
- `Array.push()`: 在数组的末尾添加一个或多个元素。
- `Array.pop()`: 删除并返回数组的最后一个元素。
- `Array.unshift()`: 在数组的开头添加一个或多个元素。
- `Array.shift()`: 删除并返回数组的第一个元素。
- `Array.slice()`: 返回数组的一部分。
- `Array.concat()`: 连接两个或多个数组。
- `Array.join()`: 将数组中的所有元素转换为一个字符串。
- `Array.forEach()`: 对数组中的每个元素执行一次回调函数。
- `Array.map()`: 对数组中的每个元素执行一次回调函数，并返回一个新的数组。
- `Array.filter()`: 返回一个由数组中符合条件的元素组成的新数组。
- `Array.reduce()`: 对数组中的每个元素执行一次回调函数，并返回一个累加值。

### Object：

- `Object.keys()`: 返回一个由对象的属性名组成的数组。
- `Object.values()`: 返回一个由对象的属性值组成的数组。
- `Object.entries()`: 返回一个由对象的键值对组成的数组。
- `Object.assign()`: 将一个或多个对象的属性复制到目标对象。
- `Object.create()`: 创建一个新对象，使用现有的对象作为新对象的原型。
- `Object.freeze()`: 冻结一个对象，防止修改其属性。
- `Object.seal()`: 封闭一个对象，防止添加或删除属性，但允许修改属性的值。
- `Object.hasOwnProperty()`: 判断一个对象是否有指定的属性。

### Promise：

- `Promise.then()`: 在 Promise 对象状态变为 resolved 时调用的回调函数。
- `Promise.catch()`: 在 Promise 对象状态变为 rejected 时调用的回调函数。
- `Promise.all()`: 将多个 Promise 对象组合成一个新的 Promise 对象，当所有 Promise 对象都变为 resolved 时，返回一个由所有 Promise 对象的结果组成的数组。
- `Promise.race()`: 将多个 Promise 对象组合成一个新的 Promise 对象，当任何一个 Promise 对象变为 resolved 或 rejected 时，返回该 Promise 对象的结果。
- `Promise.resolve()`: 返回一个状态为 resolved 的 Promise 对象。
- `Promise.reject()`: 返回一个状态为 rejected 的 Promise 对象。

总结：Number、String、Array、Object、Promise 都是 JavaScript 中常用的数据类型，每个类型都有自己的一些 API，用于处理和操作相应的数据。熟练掌握这些 API 可以帮助我们更好地处理和操作数据，提高代码的效率和质量。

## 使用 JS 如何生成一个随机字符串
你可以使用 JavaScript 生成一个随机字符串。下面是一个简单的示例，演示了如何生成指定长度的随机字符串：

```javascript
function generateRandomString(length) {
  const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    const randomIndex = Math.floor(Math.random() * charset.length);
    result += charset[randomIndex];
  }
  return result;
}

// 生成一个长度为 10 的随机字符串
const randomString = generateRandomString(10);
console.log(randomString);
```

在这个示例中，`generateRandomString` 函数接受一个参数 `length`，表示要生成的随机字符串的长度。然后，函数使用包含字母和数字的字符集，并通过循环随机选择字符，构建最终的随机字符串。

当你调用 `generateRandomString(10)` 时，它会生成一个长度为 10 的随机字符串，并将其打印到控制台上。

这只是一个简单的示例，实际应用中可能会根据具体需求进行调整，例如使用其他字符集、避免生成重复字符串等。

```javascript
const random = (n) =>
Math.random()
.toString(36)
.slice(2, 2 + n);

random();
// => "c1gdm2"
random();
// => "oir5pp"
```

这个代码示例展示了一种生成随机字符串的简洁方法。 

**代码解析:**

1. **`const random = (n) => ...`**: 定义了一个名为 `random` 的函数，它接受一个参数 `n`，表示生成的随机字符串长度。

2. **`Math.random()`**: 生成一个介于 0（包括）和 1（不包括）之间的随机浮点数。

3. **`.toString(36)`**: 将随机浮点数转换为以 36 为基数的字符串。36 进制包含 0-9 和 a-z 共 36 个字符。

4. **`.slice(2, 2 + n)`**: 从字符串的第三个字符开始 (索引 2) 截取长度为 `n` 的子字符串。 

**示例解释:**

- `random()`  : 当没有传入参数时，默认生成长度为 6 的随机字符串。

- `random(5)` : 传入 `5` 作为参数，生成长度为 5 的随机字符串。

**优点:**

- 简洁易读。
- 使用 36 进制，可以生成更长的随机字符串。

**缺点:**

- 生成的字符串可能包含重复的字符。


**总结:**

高效且易于理解的生成随机字符串的方法，适用于大多数场景。 如果你需要更复杂的随机字符串生成方式，可以考虑使用其他算法或库。

## Number.isNaN 与 globalThis.isNaN 有何区别
 `Number.isNaN` 和 `globalThis.isNaN` 都是用来判断一个值是不是 NaN 的方法，但它们存在一些细微的差别：

**1. 作用范围:**

* `Number.isNaN` 是一个静态方法，属于 `Number` 对象，因此使用 `Number.isNaN(value)` 来调用它。它只判断传入的值是否为 NaN，不考虑其类型。
* `globalThis.isNaN` 则是通过 `globalThis` 对象访问 `isNaN` 方法，属于全局对象。 `globalThis` 是一个 ECMAScript 标准，旨在提供一个跨浏览器兼容的全局对象。`globalThis.isNaN` 也会判断传入的值是否为 NaN，但它会考虑传入值的类型。

**2. 返回值:**

* `Number.isNaN(value)` 返回的是一个布尔值，表示传入的值是否为 NaN。
* `globalThis.isNaN(value)` 返回的是一个布尔值，表示传入的值是否为 NaN，但它会考虑传入值的类型。如果传入的是非数字类型，它会返回 false。

**3. 兼容性:**

* `Number.isNaN` 是一个相对较新的方法，在较新的浏览器环境中得到普遍支持。
* `globalThis.isNaN` 则是一个更古老的方法，在大多数浏览器环境中都得到支持。

**4. 使用建议:**

一般来说，建议使用 `Number.isNaN` 方法，因为它更简洁、更符合 ECMAScript 标准，并且在现代浏览器环境中得到广泛支持。如果需要兼容较旧的浏览器环境， `globalThis.isNaN` 方法。

**总结:**

`Number.isNaN` 和 `globalThis.isNaN` 都可以判断一个值是否为 NaN，但它们在作用范围、返回值和兼容性方面存在一些区别。建议使用 `Number.isNaN` 方法，因为它更简洁、更符合标准。

## 如何判断一个数值为整数
以下是一个结合使用 `Number.isInteger()` 和取模运算符 `%` 的方法：

```javascript
function isInteger(num) {
  return Number.isInteger(num) || (num % 1 === 0);
}

console.log(isInteger(5)); // true
console.log(isInteger(5.5)); // true
console.log(isInteger(3.0)); // true
console.log(isInteger(NaN)); // false
```

**解释:**

1. **`Number.isInteger(num)`**: 首先使用 `Number.isInteger()` 方法判断 `num` 是否是一个整数。如果为整数，直接返回 `true`。

2. **`num % 1 === 0`**: 如果 `Number.isInteger()` 返回 `false`，则使用取模运算符 `%` 判断 `num` 除以 1 的余数是否为 0。如果余数为 0，则表示 `num` 是整数，返回 `true`。

**优点:**

* **兼容性:** 结合使用两种方法可以兼容不同 引擎的特性，确保在大多数环境下都能正确判断整数。
* **可靠性:**  `Number.isInteger()` 方法可以准确判断整数，而取模运算符可以处理一些特殊情况，例如浮点数被强制转换为整数。

**注意:**

* `NaN` (Not a Number) 永远不会被 `Number.isInteger()` 识别为整数，因此需要单独处理。

##　同一页面三个组件请求同一个 API 发送了三次请求，如何优化
为了优化页面上三个组件请求同一个 API 的情况，可以考虑以下几种方法：

1. **合并请求：**

   将三个组件的请求合并为一个请求，这样可以减少不必要的重复请求。你可以在页面加载时或者在特定触发事件时，合并这三个请求为一个请求发送给后端。

2. **缓存数据：**

   如果这三个组件请求的数据是静态或者不经常变化的，可以考虑在前端缓存这些数据，避免重复请求。你可以使用浏览器的本地存储、sessionStorage 或者使用一些状态管理工具来缓存数据。

3. **使用状态管理：**

   如果这三个组件之间有共享的数据，可以考虑使用状态管理工具（如 Redux、Vuex 等）来管理数据。这样可以避免重复请求相同的数据，而是共享已经请求过的数据。

4. **使用服务端缓存：**

   如果这三个请求的数据在服务端不经常变化，可以在服务端实现缓存机制，减少对相同数据的重复请求。

5. **延迟加载：**

   如果这三个组件不是页面加载时必须立即展示的内容，可以考虑延迟加载这些组件，等页面加载完成后再发送请求获取数据。

6. **请求节流或者防抖：**

   使用请求节流或者防抖的技术来控制请求发送的频率，避免过多的请求发送到后端。节流可以控制请求发送的时间间隔，防抖可以在一段时间内只发送一次请求。

通过以上优化方法，可以有效地减少对相同 API 的重复请求，提高页面性能和用户体验。根据具体情况选择合适的优化方法，可以更好地优化页面性能。

## 简述 koa 的中间件原理，手写 koa-compose 代码
Koa 是一个流行的 Node.js Web 框架，它使用中间件来处理 HTTP 请求。中间件是一个函数，它可以访问请求对象、响应对象以及应用程序的下一个中间件函数。Koa 使用洋葱模型（onion model）来组织中间件，请求会从外层中间件依次经过内层中间件，然后再返回到外层中间件。

`koa-compose` 是 Koa 中间件组合的一个常用工具，它将一组中间件函数组合成一个大的中间件函数。下面是一个简化的 `koa-compose` 的手写实现：

```javascript
function compose(middleware) {
  return function (context, next) {
    let index = -1;
    return dispatch(0);
    
    function dispatch(i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'));
      index = i;
      let fn = middleware[i];
      if (i === middleware.length) fn = next;
      if (!fn) return Promise.resolve();
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err);
      }
    }
  };
}
```

这段代码实现了一个简单的 `compose` 函数，它接受一个中间件数组 `middleware`，返回一个组合后的中间件函数。这个组合后的中间件函数接受 `context` 和 `next` 两个参数，用来模拟 Koa 中间件的调用方式。

在组合后的中间件函数中，通过递归调用 `dispatch` 函数来依次执行每个中间件。每个中间件函数都接受 `context` 和 `next` 两个参数，`next` 参数是一个函数，用来调用下一个中间件。当所有中间件执行完毕后，会返回一个 resolved 的 Promise。

这个实现并没有考虑 Koa 中间件的一些复杂情况，例如错误处理、异步中间件的处理等。实际上，`koa-compose` 还包含了对这些情况的处理。但以上代码足以展示 `koa-compose` 的基本原理，即将一组中间件组合成一个大的中间件，并按照洋葱模型依次执行每个中间件。

## 如何压缩前端项目中 JS 的体积
压缩前端项目中 JavaScript 的体积是优化前端性能的重要步骤之一。以下是一些常用的方法来压缩前端项目中的 JavaScript 文件：

1. **使用压缩工具：**
   - **UglifyJS：** UglifyJS 是一个常用的 JavaScript 压缩工具，可以删除空格、注释、重复代码，并且可以进行代码混淆。你可以使用 UglifyJS 来压缩你的 JavaScript 文件。
   - **Terser：** Terser 是一个 JavaScript 压缩工具，它是 UglifyJS 的继任者，提供了更好的压缩效果和速度。

2. **移除不必要的代码：**
   - 检查你的代码库，移除不再使用的代码、无用的变量和函数，以减少文件体积。
   - 避免引入不必要的第三方库，只引入项目中需要的功能，可以减少代码体积。

3. **模块化开发：**
   - 使用模块化开发，将代码拆分为多个模块，按需加载，可以减少页面初始加载时需要下载的 JavaScript 文件的体积。
   - 使用工具（如 Webpack、Rollup 等）对模块进行打包，减少冗余代码。

4. **启用 gzip 压缩：**
   - 在服务器端启用 gzip 压缩，可以减小传输过程中的文件体积。大多数 Web 服务器都支持 gzip 压缩，可以通过配置来开启。

5. **使用 Tree Shaking：**
   - Tree Shaking 是一种通过静态分析代码来移除未被使用代码的技术。在使用 ES6 模块化的项目中，工具如 Webpack 可以通过 Tree Shaking 来移除未使用的代码，减小文件体积。

6. **代码分割：**
   - 使用代码分割技术，按需加载代码，减少初始加载时需要下载的 JavaScript 文件的体积。可以使用动态 import 或者工具进行代码分割。

7. **使用 CDN：**
   - 将一些公共的库或者框架（如 jQuery、React、Vue 等）通过 CDN 引入，可以减少项目本身的体积。

通过结合以上方法，你可以有效地压缩前端项目中 JavaScript 的体积，提高页面加载性能，减少用户等待时间。

## 实现一个函数 maxBy，根据给定条件找到最大的数组项 如果最大的项有多个，则多个都返回
好的，我来详细解释一下 `maxBy` 函数的代码：

```javascript
function maxBy(arr, condition) {
    if (arr.length === 0) {
        return [];
    }

    const maxVal = Math.max(...arr.map(condition));
    return arr.filter(item => condition(item) === maxVal);
}
```

**1. 函数定义:**

* `function maxBy(arr, condition)`: 定义了一个名为 `maxBy` 的函数，它接受两个参数：
    * `arr`: 一个要查找最大值的数组。
    * `condition`: 一个函数，用于定义“最大值”的条件。它接受数组中的一个元素作为参数，并返回一个值。

**2. 空数组处理:**

* `if (arr.length === 0) { return []; }`: 如果传入的数组为空，则直接返回一个空数组，避免后续操作出错。

**3. 找到最大值:**

* `const maxVal = Math.max(...arr.map(condition));`: 这是核心逻辑，它通过以下步骤找到最大值：
    * `arr.map(condition)`: 使用 `map` 方法遍历数组 `arr`，对每个元素应用 `condition` 函数，并将结果存储在一个新数组中。
    * `...`: 展开运算符将新数组中的所有值作为参数传递给 `Math.max` 函数。
    * `Math.max(...)`: `Math.max` 函数接受多个参数，并返回其中最大的值。

**4. 筛选符合条件的元素:**

* `return arr.filter(item => condition(item) === maxVal);`: 使用 `filter` 方法筛选数组 `arr`，只保留那些满足以下条件的元素：
    * `condition(item) === maxVal`: 条件函数应用于当前元素 `item` 的返回值必须等于找到的最大值 `maxVal`。

**5. 返回结果:**

* `return ...`: 返回筛选后的数组，包含所有符合条件的最大值。



**总结:**

`maxBy` 函数利用了 的内置方法 `map` 和 `filter`，以及 `Math.max` 函数，高效地找到了符合条件的最大值。你可以根据你的需求修改 `condition` 函数，来找到不同类型的最大值。

## 统计字符串中出现次数最多的字符及次数 并解释原理
要统计字符串中出现次数最多的字符及其出现次数，可以使用 JavaScript 编写一个函数来实现。下面是一个示例代码：

```javascript
function findMostFrequentChar(str) {
    const charMap = {};
    let maxChar = '';
    let maxCount = 0;

    for (let char of str) {
        if (charMap[char]) {
            charMap[char]++;
        } else {
            charMap[char] = 1;
        }

        if (charMap[char] > maxCount) {
            maxChar = char;
            maxCount = charMap[char];
        }
    }

    return { char: maxChar, count: maxCount };
}

// 示例用法
const result = findMostFrequentChar("abracadabra");
console.log(result); // 输出 { char: 'a', count: 5 }
```

**函数原理解释:**

1. **创建字符映射对象：** 
   - 首先，我们创建一个空的对象 `charMap`，用于存储每个字符出现的次数。同时，我们定义两个变量 `maxChar` 和 `maxCount`，用于记录出现次数最多的字符及其出现次数。

2. **遍历字符串：**
   - 接下来，我们遍历输入的字符串 `str` 中的每个字符。
   - 对于每个字符，我们检查它是否已经在 `charMap` 中存在。
     - 如果存在，我们将对应的计数加一。
     - 如果不存在，我们将该字符添加到 `charMap` 中，并将其计数设为 1。

3. **更新最大值：**
   - 在更新 `charMap` 的过程中，我们同时比较每个字符的计数与 `maxCount`。
     - 如果某个字符的计数大于 `maxCount`，我们就更新 `maxChar` 和 `maxCount` 的值为当前字符和其计数。

4. **返回结果：**
   - 最后，我们返回一个对象，其中包含出现次数最多的字符 `maxChar` 和其出现次数 `maxCount`。

这样，我们就可以通过该函数找到字符串中出现次数最多的字符及其出现次数。这个算法的时间复杂度是 O(n)，其中 n 是输入字符串的长度，因为它需要遍历整个字符串来统计字符出现的次数。

## 请输出 100 以内的菲波那切数列 解释原理
菲波那切数列是一个经典的数学问题，可以通过递归或迭代的方式生成。以下是一个 JavaScript 函数来输出 100 以内的菲波那切数列：

```javascript
function fibonacciSequence(limit) {
    const sequence = [0, 1];
    let nextTerm = 0;

    while (true) {
        nextTerm = sequence[sequence.length - 1] + sequence[sequence.length - 2];
        if (nextTerm > limit) {
            break;
        }
        sequence.push(nextTerm);
    }

    return sequence;
}

const result = fibonacciSequence(100);
console.log(result); // 输出 [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
```

**原理解释:**

1. **初始化数列：**
   - 我们首先创建一个数组 `sequence`，并初始化为 `[0, 1]`，因为菲波那切数列的前两个数字是 0 和 1。

2. **生成数列：**
   - 然后，我们进入一个循环，不断计算下一个菲波那切数。
   - 下一个菲波那切数可以通过将数列中最后两个数相加得到。

3. **限制范围：**
   - 在每次生成下一个数时，我们检查该数是否超过了限制值（这里是 100）。
   - 如果超过了限制值，我们就退出循环，不再生成更大的数。

4. **返回结果：**
   - 最后，我们返回生成的菲波那切数列。

菲波那切数列的特点是，每个数字都是前两个数字之和。这个算法的时间复杂度是 O(n)，其中 n 是生成的菲波那切数列的长度。因为我们只需要遍历一次来生成数列，所以这个算法是非常高效的。