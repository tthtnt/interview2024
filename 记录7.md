## 当 cookie 没有设置 maxage 时，cookie 会存在多久
当 Cookie 没有设置 maxAge（或 expires）时，它的生命周期取决于浏览器的行为，通常被称为"会话 Cookie"（Session Cookie）。这种 Cookie 的存在时间如下：

1. 浏览器会话期间：
   - Cookie 会在整个浏览器会话期间保持有效。
   - 只要浏览器窗口或标签页保持打开状态，Cookie 就会存在。

2. 浏览器关闭时：
   - 当用户关闭浏览器（所有窗口和标签页）时，会话 Cookie 通常会被删除。

3. 特殊情况：
   - 某些浏览器（如 Chrome）在关闭后重新打开时可能会恢复之前的会话，这可能导致会话 Cookie 被保留。
   - 一些浏览器提供"恢复上次会话"的功能，这也可能导致会话 Cookie 被保留。

4. 浏览器设置：
   - 用户的浏览器设置可能影响 Cookie 的行为。例如，某些浏览器可能被配置为在关闭时保留所有 Cookie。

5. 隐私模式：
   - 在浏览器的隐私模式（如 Chrome 的隐身模式）下，会话 Cookie 通常会在关闭窗口时立即删除。

6. 移动设备：
   - 在移动设备上，某些应用可能会在后台保持活跃状态，这可能导致会话 Cookie 的生命周期延长。

7. 崩溃恢复：
   - 如果浏览器意外崩溃并恢复，某些会话 Cookie 可能会被保留。

重要注意事项：

- 不同浏览器和版本可能对会话 Cookie 的处理有细微差异。
- 为了确保 Cookie 在特定时间后失效，最好明确设置 maxAge 或 expires 属性。
- 对于敏感信息，不应该依赖会话 Cookie 的自动删除机制，而应该实施更严格的安全措施。

总的来说，没有设置 maxAge 的 Cookie 通常会在浏览器会话结束时被删除，但具体行为可能因浏览器、设置和使用情况而异。为了更精确地控制 Cookie 的生命周期，建议明确设置过期时间。

## 手写Promise.race
手写 `Promise.race` 的实现需要理解 `Promise.race` 的基本行为：它接收一个可迭代对象（通常是一个数组）作为参数，并返回一个新的 `Promise`。这个新的 `Promise` 会在传入的第一个 `Promise` 解决（resolve）或拒绝（reject）时解决或拒绝。

下面是一个手写 `Promise.race` 的实现：

```javascript
function customPromiseRace(promises) {
  // 返回一个新的 Promise
  return new Promise((resolve, reject) => {
    // 遍历传入的所有 Promise
    for (let p of promises) {
      // 使用 Promise.resolve 将每个项转换为 Promise（以防传入的不是 Promise）
      Promise.resolve(p).then(resolve, reject);
    }
  });
}

// 示例使用
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => resolve('Promise 1 resolved'), 500);
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => resolve('Promise 2 resolved'), 300);
});

const promise3 = new Promise((resolve, reject) => {
  setTimeout(() => reject('Promise 3 rejected'), 100);
});

customPromiseRace([promise1, promise2, promise3])
  .then(value => {
    console.log('Resolved with:', value);
  })
  .catch(error => {
    console.log('Rejected with:', error);
  });
```

### 解释

1. **返回一个新的 `Promise`**：
   - `customPromiseRace` 函数返回一个新的 `Promise` 实例。

2. **遍历传入的所有 `Promise`**：
   - 使用 `for...of` 循环遍历传入的 `promises` 可迭代对象。

3. **使用 `Promise.resolve` 包装每个项**：
   - `Promise.resolve(p)` 确保每个传入的项都被转换为 `Promise`，即使它本身不是 `Promise`（例如，一个普通值）。

4. **处理每个 `Promise` 的解决和拒绝**：
   - 对每个 `Promise`，调用 `then(resolve, reject)`。当任意一个 `Promise` 解决或拒绝时，新的 `Promise` 就会相应地解决或拒绝。
   - 由于 `Promise.race` 的特性，第一个解决或拒绝的 `Promise` 会决定最终结果。

### 示例解释

在示例中，有三个 `Promise`：

- `promise1` 在 500 毫秒后解决。
- `promise2` 在 300 毫秒后解决。
- `promise3` 在 100 毫秒后拒绝。

由于 `promise3` 最先拒绝，`customPromiseRace` 返回的 `Promise` 会立即拒绝，并输出 `Rejected with: Promise 3 rejected`。

这个实现展示了 `Promise.race` 的核心逻辑：在一组 `Promise` 中，第一个解决或拒绝的 `Promise` 会决定返回的 `Promise` 的结果。

##　在浏览器中如何获取剪切板中内容
在现代浏览器中，可以使用 Clipboard API 来访问剪贴板的内容。特别是 `navigator.clipboard.readText()` 方法可以用于读取剪贴板中的文本内容。需要注意的是，出于安全和隐私的考虑，访问剪贴板通常需要用户的明确许可，通常是在用户交互（如点击按钮）之后进行。

以下是一个示例，演示如何在浏览器中获取剪贴板中的内容：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clipboard API Example</title>
</head>
<body>
    <button id="pasteButton">Paste from Clipboard</button>
    <p id="clipboardContent"></p>

    <script>
        document.getElementById('pasteButton').addEventListener('click', async () => {
            try {
                // 读取剪贴板中的文本内容
                const text = await navigator.clipboard.readText();
                // 将读取到的内容显示在页面上
                document.getElementById('clipboardContent').textContent = `Clipboard Content: ${text}`;
            } catch (err) {
                console.error('Failed to read clipboard contents: ', err);
            }
        });
    </script>
</body>
</html>
```

### 解释

1. **HTML结构**：
   - 一个按钮用于触发读取剪贴板内容的操作。
   - 一个段落标签用于显示读取到的剪贴板内容。

2. **JavaScript**：
   - 给按钮添加一个点击事件监听器。
   - 在事件处理函数中，使用 `navigator.clipboard.readText()` 方法异步读取剪贴板中的文本内容。
   - 将读取到的内容显示在页面的段落标签中。
   - 使用 `try...catch` 块来处理可能的错误，例如用户拒绝权限请求或浏览器不支持 Clipboard API。

### 注意事项

1. **权限**：
   - 访问剪贴板内容需要用户的明确许可。通常，这需要在用户交互（如点击按钮）之后进行。
   - 某些浏览器可能会在没有用户交互的情况下拒绝访问剪贴板。

2. **浏览器支持**：
   - Clipboard API 是现代浏览器中的特性，旧版本的浏览器可能不支持这个 API。
   - 可以使用 `if (!navigator.clipboard)` 来检查浏览器是否支持 Clipboard API。

3. **安全性**：
   - 由于剪贴板可能包含敏感信息，访问剪贴板内容应谨慎，并遵循用户隐私和安全最佳实践。

通过这种方式，你可以在用户的明确操作下安全地读取剪贴板中的内容，并在浏览器中进行相应的处理。

## 有哪些 css 属性不能展示动画效果
在 CSS 中，并不是所有属性都可以应用动画效果。CSS 动画效果（包括过渡和关键帧动画）仅适用于那些具有中间状态的属性，也就是说，这些属性在从一个值过渡到另一个值时可以有中间状态。

以下是一些不能展示动画效果的 CSS 属性：

1. **布局相关属性**：
   - `display`：无法在不同的显示模式之间进行动画过渡。
   - `position`：无法在不同的定位模式之间进行动画过渡（例如，从 `static` 到 `absolute`）。
   - `float`：无法在 `left`、`right` 和 `none` 之间进行动画过渡。
   - `clear`：无法在 `none`、`left`、`right` 和 `both` 之间进行动画过渡。

2. **几何形状相关属性**：
   - `clip`：尽管 `clip-path` 可以动画化，但 `clip` 属性本身不能。
   - `overflow`：无法在 `visible`、`hidden`、`scroll` 和 `auto` 之间进行动画过渡。

3. **表格相关属性**：
   - `border-collapse`：无法在 `collapse` 和 `separate` 之间进行动画过渡。
   - `table-layout`：无法在 `auto` 和 `fixed` 之间进行动画过渡。
   - `empty-cells`：无法在 `show` 和 `hide` 之间进行动画过渡。

4. **其他属性**：
   - `white-space`：无法在不同的空白处理模式之间进行动画过渡。
   - `unicode-bidi`：无法在不同的双向文本处理模式之间进行动画过渡。
   - `content`：无法在不同的内容值之间进行动画过渡。
   - `cursor`：无法在不同的光标类型之间进行动画过渡。

### 解释

- **中间状态**：动画效果需要属性在两个值之间有中间状态。例如，颜色属性 `color` 可以在红色和蓝色之间平滑过渡，因为它可以有中间颜色（如紫色）。而 `display` 属性没有中间状态，它要么是 `block`，要么是 `none`，没有中间状态。
- **数值属性**：大多数可以动画化的属性都是数值属性或可以被解释为数值的属性。例如，尺寸（如 `width`、`height`）、位置（如 `left`、`top`）、颜色（如 `color`、`background-color`）等。

### 可动画化属性示例

以下是一些常见的可以应用动画效果的 CSS 属性：

- 尺寸和位置：`width`、`height`、`left`、`right`、`top`、`bottom`、`margin`、`padding`
- 颜色：`color`、`background-color`、`border-color`
- 透明度：`opacity`
- 变换：`transform`（包括 `translate`、`rotate`、`scale` 等）
- 字体：`font-size`、`font-weight`
- 其他：`box-shadow`、`text-shadow`、`border-radius`

在实际使用中，选择适合的 CSS 属性进行动画效果，可以提升用户体验和界面交互的流畅性。

## 为什么会发生样式抖动
样式抖动（Layout Jank）是指在网页渲染过程中，由于样式和布局的频繁变化，导致页面元素的意外移动或闪烁。这种现象会影响用户体验，使页面看起来不稳定和不流畅。样式抖动通常发生在以下几种情况下：

### 1. 动态内容加载
当页面上的内容动态加载或更新时，可能会导致布局的重新计算和重绘。例如，图片、广告、或异步加载的数据突然插入到页面中，可能会导致页面布局发生变化。

### 2. 窗口大小调整
当用户调整浏览器窗口大小时，页面需要重新计算布局。这可能导致元素位置和大小的变化，从而引起抖动。

### 3. CSS 动画和过渡
不当使用 CSS 动画和过渡效果，尤其是对布局影响较大的属性（如 `width`、`height`、`margin`、`padding`）进行动画处理，可能会导致频繁的布局重新计算和重绘，从而引起抖动。

### 4. JavaScript 操作 DOM
频繁通过 JavaScript 操作 DOM，尤其是对大量元素进行增删改操作，会导致浏览器频繁进行布局计算和重绘。例如，频繁地插入或删除节点，或频繁地修改元素的样式属性。

### 5. 缺乏性能优化
页面没有进行适当的性能优化，例如没有使用 `will-change` 提示浏览器哪些元素会发生变化，或者没有对复杂动画进行硬件加速处理，都会导致页面渲染性能下降，从而引起抖动。

### 如何减少样式抖动

1. **使用 CSS 动画和过渡时避免影响布局的属性**：
   - 优先使用对布局影响较小的属性进行动画，例如 `transform` 和 `opacity`。这些属性不会触发布局重新计算，只会触发合成和绘制。

2. **优化动态内容加载**：
   - 预留空间：在加载动态内容（如图片或广告）之前，预留足够的空间，避免内容加载后导致布局变化。
   - 渐进式加载：使用懒加载技术，逐步加载内容，减少一次性加载大量内容对布局的影响。

3. **减少和优化 JavaScript 操作 DOM**：
   - 批量操作：将多次对 DOM 的操作合并为一次操作，减少布局重新计算的次数。
   - 使用 `requestAnimationFrame`：在进行复杂的 DOM 操作时，使用 `requestAnimationFrame` 确保操作在浏览器的渲染周期内进行。

4. **使用 `will-change` 提示浏览器**：
   - 对即将发生变化的元素使用 `will-change` 属性，提示浏览器提前进行优化。例如：
     ```css
     .animated-element {
         will-change: transform, opacity;
     }
     ```

5. **避免频繁的样式计算**：
   - 避免在布局和绘制过程中频繁读取和写入样式属性，这会导致强制同步布局。使用 `getComputedStyle` 或直接访问元素的样式属性时要小心，尽量减少这种操作的频率。

通过上述方法，可以有效减少样式抖动，提升页面的渲染性能和用户体验。

## position: sticky 如何工作，适用于哪些场景
`position: sticky` 是 CSS 定位属性的一个相对较新的值，它提供了一种独特的定位方式，结合了相对定位（relative）和固定定位（fixed）的特性。这个属性在许多现代场景中非常有用，特别是在创建滚动时保持某些元素可见的界面时。让我们详细了解它的工作原理和适用场景。

### 工作原理

1. **初始行为**：
   - 元素最初表现得像是 `position: relative`。

2. **滚动触发**：
   - 当元素的容器滚动到特定点（由 `top`、`right`、`bottom`、`left` 属性定义）时，元素的行为会改变。

3. **固定状态**：
   - 一旦触发条件满足，元素就会像 `position: fixed` 一样固定在屏幕上的指定位置。

4. **限制范围**：
   - 元素的固定状态仅限于其父容器内。当到达父容器的边界时，元素会停止固定。

5. **恢复初始状态**：
   - 当滚动回到触发点之前，元素会恢复到其原始位置。

### 示例代码

```css
.sticky-element {
    position: sticky;
    top: 20px; /* 当元素距离视口顶部 20px 时开始固定 */
}
```

### 适用场景

1. **固定导航栏**：
   - 在长页面中，当用户滚动到一定程度后，保持导航栏可见。

2. **表格头部固定**：
   - 在长表格中，保持表头始终可见，便于用户查看列标题。

3. **侧边栏导航**：
   - 在长文章或文档页面中，保持侧边导航栏可见，方便用户快速跳转。

4. **分类标题**：
   - 在列表或目录中，当滚动到新的分类时，保持分类标题可见。

5. **广告或提示框**：
   - 在页面滚动时，保持广告或重要提示信息可见，但不影响整体布局。

6. **图片画廊标题**：
   - 在图片画廊中，当滚动到新图片时，保持图片标题或描述可见。

7. **日历应用中的日期栏**：
   - 在滚动查看事件时，保持日期栏可见。

8. **社交媒体Feed中的日期分隔符**：
   - 在滚动查看帖子时，保持日期分隔符可见，便于了解时间线。

### 注意事项

1. **父容器限制**：
   - `sticky` 元素的固定效果仅在其父容器内有效。如果父容器高度结束，`sticky` 元素也会随之消失。

2. **溢出处理**：
   - 父容器必须允许滚动（不能设置 `overflow: hidden`）。

3. **兼容性**：
   - 虽然现代浏览器普遍支持，但在一些旧版浏览器中可能不起作用。

4. **z-index 考虑**：
   - 在复杂布局中，可能需要调整 `z-index` 以确保 `sticky` 元素正确显示在其他内容之上。

5. **性能影响**：
   - 过多使用 `sticky` 元素可能会影响滚动性能，特别是在移动设备上。

### 示例：固定导航栏

```html
<header>
    <nav class="sticky-nav">
        <ul>
            <li><a href="#home">Home</a></li>
            <li><a href="#about">About</a></li>
            <li><a href="#contact">Contact</a></li>
        </ul>
    </nav>
</header>
<main>
    <!-- 页面内容 -->
</main>
```

```css
.sticky-nav {
    position: sticky;
    top: 0;
    background-color: #fff;
    padding: 10px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
```

这个例子创建了一个在页面滚动时会固定在顶部的导航栏，提供了良好的用户体验，特别是在长页面中。

总的来说，`position: sticky` 是一个强大的 CSS 特性，能够在许多现代网页设计中创造出流畅、直观的用户界面。它特别适合那些需要在滚动过程中保持某些元素可见，同时又不想完全脱离文档流的场景。

## js 中在 new 的时候发生了什么
在 JavaScript 中，当使用 `new` 关键字创建一个对象时，会发生一系列的步骤。这个过程涉及到函数调用、原型链和对象创建。让我们详细探讨一下 `new` 操作符的工作原理：

### `new` 操作符的执行步骤

当执行 `new Constructor(arguments)` 时，JavaScript 引擎会执行以下步骤：

1. **创建一个新对象**：
   首先，创建一个全新的空对象。

2. **设置原型**：
   将这个新对象的 `[[Prototype]]`（也就是 `__proto__`）链接到构造函数的 `prototype` 属性。

3. **执行构造函数**：
   将构造函数的 `this` 绑定到新创建的对象，然后执行构造函数，为这个新对象添加属性。

4. **返回新对象**：
   如果构造函数没有显式返回一个对象，则返回这个新创建的对象。如果构造函数返回了一个对象，则返回该对象。

### 示例代码

让我们通过一个例子来说明这个过程：

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.sayHello = function() {
    console.log(`Hello, my name is ${this.name}`);
};

const john = new Person("John", 30);
```

在这个例子中，当执行 `new Person("John", 30)` 时：

1. 创建一个新的空对象。
2. 这个新对象的 `__proto__` 被设置为 `Person.prototype`。
3. `Person` 函数被调用，`this` 被绑定到新对象，设置 `name` 和 `age` 属性。
4. 由于 `Person` 函数没有显式返回对象，所以返回这个新创建的对象。

### 模拟 `new` 操作符

为了更好地理解 `new` 的工作原理，我们可以实现一个函数来模拟 `new` 的行为：

```javascript
function myNew(Constructor, ...args) {
    // 1. 创建一个新对象，链接到构造函数的原型
    const obj = Object.create(Constructor.prototype);
    
    // 2. 执行构造函数，并将 this 绑定到新对象
    const result = Constructor.apply(obj, args);
    
    // 3. 如果构造函数返回了一个对象，就返回这个对象，否则返回新创建的对象
    return (typeof result === 'object' && result !== null) ? result : obj;
}

// 使用示例
const jane = myNew(Person, "Jane", 25);
jane.sayHello(); // 输出: Hello, my name is Jane
```

### 注意事项

1. **返回值处理**：
   如果构造函数显式返回一个对象，`new` 操作符会返回这个对象，而不是新创建的实例。

   ```javascript
   function SpecialPerson(name) {
       this.name = name;
       return { special: true };
   }
   
   const special = new SpecialPerson("Special");
   console.log(special); // { special: true }
   ```

2. **原型链**：
   通过 `new` 创建的对象会继承构造函数原型上的方法和属性。

3. **箭头函数**：
   箭头函数不能用作构造函数，因为它们没有自己的 `this` 绑定。

4. **`new.target`**：
   在构造函数内部，可以使用 `new.target` 来检测函数是否被作为构造函数调用。

   ```javascript
   function Person(name) {
       if (!new.target) {
           return new Person(name);
       }
       this.name = name;
   }
   ```

5. **性能考虑**：
   频繁使用 `new` 创建对象可能会影响性能，特别是在需要创建大量相似对象的情况下。在这种情况下，可以考虑使用对象池或工厂模式等优化技术。

理解 `new` 操作符的工作原理对于深入理解 JavaScript 的对象模型和原型继承非常重要。它不仅帮助我们更好地使用构造函数创建对象，也为理解更复杂的面向对象模式奠定了基础。

## 如何把 json 数据转化为 demo.json 并下载文件
将 JSON 数据转换为文件并下载是一个常见的前端需求。以下是几种实现这个功能的方法，从最简单到较复杂的实现：

### 方法 1：使用 Blob 和 URL.createObjectURL

这是一种简单且广泛支持的方法：

```javascript
function downloadJSON(data, filename = 'demo.json') {
    // 将 JSON 对象转换为字符串
    const jsonString = JSON.stringify(data, null, 2);
    
    // 创建一个 Blob
    const blob = new Blob([jsonString], { type: 'application/json' });
    
    // 创建一个 URL 对象
    const url = URL.createObjectURL(blob);
    
    // 创建一个 a 标签
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    
    // 模拟点击下载
    document.body.appendChild(a);
    a.click();
    
    // 清理
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// 使用示例
const data = { name: "John", age: 30 };
downloadJSON(data);
```

### 方法 2：使用 FileSaver.js 库

如果你不介意使用外部库，FileSaver.js 提供了一个简单的 API：

首先，安装 FileSaver.js：

```bash
npm install file-saver
```

然后在你的代码中使用：

```javascript
import { saveAs } from 'file-saver';

function downloadJSON(data, filename = 'demo.json') {
    const jsonString = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    saveAs(blob, filename);
}

// 使用示例
const data = { name: "John", age: 30 };
downloadJSON(data);
```

### 方法 3：使用 Data URI

这种方法不创建 Blob，而是使用 Data URI：

```javascript
function downloadJSON(data, filename = 'demo.json') {
    const jsonString = JSON.stringify(data, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(jsonString);
    
    const a = document.createElement('a');
    a.href = dataUri;
    a.download = filename;
    
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

// 使用示例
const data = { name: "John", age: 30 };
downloadJSON(data);
```

### 方法 4：使用 Fetch API（仅适用于服务器端生成的 JSON）

如果 JSON 数据是由服务器生成的，你可以使用 Fetch API：

```javascript
function downloadJSON(url, filename = 'demo.json') {
    fetch(url)
        .then(response => response.blob())
        .then(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
}

// 使用示例
downloadJSON('/api/data.json', 'mydata.json');
```

### 注意事项

1. **大文件处理**：对于非常大的 JSON 数据，考虑使用流式处理或分块下载。

2. **跨浏览器兼容性**：上述方法在现代浏览器中都能很好地工作，但在旧版浏览器中可能需要额外的兼容性处理。

3. **文件名编码**：在某些浏览器中，非 ASCII 字符的文件名可能需要特殊处理。

4. **安全考虑**：如果数据包含敏感信息，确保在客户端生成文件是安全的。

5. **用户体验**：考虑添加加载指示器或进度条，特别是对于大文件。

6. **内存使用**：对于非常大的 JSON 对象，注意内存使用情况，可能需要考虑流式处理或分块处理。

选择哪种方法取决于你的具体需求、目标浏览器和是否愿意使用外部库。方法 1 是最通用和直接的方法，适合大多数情况。如果你经常需要处理文件下载，使用 FileSaver.js 这样的库可能会更方便。

## 伪类与伪元素有什么区别
在 CSS 中，伪类和伪元素是两种不同的概念，它们用于选择和样式化特定的元素状态或特定的部分。尽管它们看起来相似，但它们有不同的用途和语法。以下是伪类和伪元素的区别：

### 伪类（Pseudo-classes）

伪类用于选择元素的特定状态或特征，这些状态或特征不能通过常规的 CSS 选择器来表示。伪类通常以单个冒号 `:` 开头。

#### 常见的伪类

- `:hover`：当鼠标悬停在元素上时应用样式。
- `:focus`：当元素获得焦点时应用样式。
- `:active`：当元素被激活（通常是被点击）时应用样式。
- `:nth-child(n)`：选择父元素的第 n 个子元素。
- `:first-child`：选择父元素的第一个子元素。
- `:last-child`：选择父元素的最后一个子元素。
- `:not(selector)`：选择与给定选择器不匹配的元素。

#### 示例

```css
/* 当鼠标悬停在按钮上时改变背景颜色 */
button:hover {
    background-color: blue;
}

/* 选择第一个段落 */
p:first-child {
    color: red;
}
```

### 伪元素（Pseudo-elements）

伪元素用于选择和样式化元素的一部分，它们通常用于样式化元素的特定部分或插入内容。伪元素通常以双冒号 `::` 开头（在 CSS3 之前，单冒号 `:` 也可以用于伪元素，但现在推荐使用双冒号）。

#### 常见的伪元素

- `::before`：在元素内容之前插入内容。
- `::after`：在元素内容之后插入内容。
- `::first-line`：选择元素的第一行。
- `::first-letter`：选择元素的第一个字母。
- `::placeholder`：选择输入元素的占位符文本。

#### 示例

```css
/* 在段落内容之前插入一个引号 */
p::before {
    content: "“";
    font-size: 2em;
    color: gray;
}

/* 在段落内容之后插入一个引号 */
p::after {
    content: "”";
    font-size: 2em;
    color: gray;
}

/* 对段落的第一行应用样式 */
p::first-line {
    font-weight: bold;
}

/* 对段落的第一个字母应用样式 */
p::first-letter {
    font-size: 2em;
    color: red;
}
```

### 总结

- **伪类**：
  - 用于选择元素的特定状态或特征。
  - 以单冒号 `:` 开头。
  - 示例：`:hover`, `:focus`, `:nth-child(n)`。

- **伪元素**：
  - 用于选择和样式化元素的一部分，或插入内容。
  - 以双冒号 `::` 开头（CSS3 之前也可以用单冒号）。
  - 示例：`::before`, `::after`, `::first-line`, `::first-letter`。

了解伪类和伪元素的区别有助于更灵活和精确地进行 CSS 样式设计。

## 什么是 Iterable 对象，与 Array 有什么区别
Iterable 对象和 Array 是 JavaScript 中两个相关但不完全相同的概念。让我们深入了解它们的特点和区别：

### Iterable 对象

1. **定义**：
   Iterable 对象是实现了 Iterator 接口的对象，可以被迭代（例如在 for...of 循环中使用）。

2. **特征**：
   - 必须实现 @@iterator 方法（通过 Symbol.iterator 键访问）。
   - 这个方法返回一个 iterator 对象，该对象有一个 next() 方法。
   - next() 方法返回一个包含 value 和 done 属性的对象。

3. **内置的 Iterable 类型**：
   - Array
   - String
   - Map
   - Set
   - TypedArray
   - arguments 对象
   - NodeList

4. **使用场景**：
   - for...of 循环
   - 展开运算符 (...)
   - 解构赋值
   - Array.from()
   - new Map(), new Set() 等构造函数

5. **示例**：
   ```javascript
   let iterable = {
     [Symbol.iterator]() {
       let i = 0;
       return {
         next() {
           if (i < 3) {
             return { value: i++, done: false };
           }
           return { done: true };
         }
       };
     }
   };

   for (let value of iterable) {
     console.log(value); // 输出 0, 1, 2
   }
   ```

### Array

1. **定义**：
   Array 是 JavaScript 中的一种特定数据结构，用于存储有序的元素集合。

2. **特征**：
   - 有索引
   - 有 length 属性
   - 继承自 Array.prototype，拥有许多内置方法（如 push, pop, map, filter 等）
   - 是 Iterable 对象的一种

3. **使用场景**：
   - 存储和操作有序数据
   - 利用数组方法进行数据处理

4. **示例**：
   ```javascript
   let array = [1, 2, 3];
   array.push(4);
   console.log(array.length); // 4
   console.log(array[2]); // 3
   ```

### 区别

1. **范围**：
   - 所有的 Array 都是 Iterable 对象。
   - 但不是所有的 Iterable 对象都是 Array。

2. **方法和属性**：
   - Array 有很多特定的方法和属性（如 push, pop, length）。
   - Iterable 对象不一定有这些方法和属性。

3. **索引访问**：
   - Array 可以通过索引直接访问元素。
   - Iterable 对象不一定支持索引访问。

4. **长度**：
   - Array 有 length 属性。
   - Iterable 对象不一定有 length 属性。

5. **创建和使用**：
   - Array 可以直接使用字面量 [] 或 Array 构造函数创建。
   - 创建自定义 Iterable 对象需要实现 Symbol.iterator 方法。

6. **灵活性**：
   - Iterable 对象可以表示无限序列或延迟计算的序列。
   - Array 通常表示有限且已知的元素集合。

### 总结

虽然 Array 是 Iterable 对象的一种，但它是一个更具体、功能更丰富的数据结构。Iterable 对象提供了一种更通用的迭代接口，允许不同类型的对象以统一的方式被迭代，而 Array 则提供了更多专门用于处理有序集合的方法和属性。了解这两者的区别和联系，可以帮助我们在不同场景下选择更合适的数据结构和处理方式。

## js 如何全部替代一个子串为另一个子串
在 JavaScript 中，如果你想将一个字符串中的所有子串替换为另一个子串，可以使用多种方法。最常用的方法是使用正则表达式或 `replaceAll` 方法。以下是几种常见的方法：

### 方法一：使用 `replace` 方法和正则表达式

使用正则表达式的全局标志 `g` 可以替换所有匹配的子串。

```javascript
let str = "Hello world! Hello everyone!";
let newStr = str.replace(/Hello/g, "Hi");
console.log(newStr); // 输出 "Hi world! Hi everyone!"
```

### 方法二：使用 `replaceAll` 方法

`replaceAll` 方法是 ES2021 (ES12) 中引入的，它可以直接替换所有匹配的子串。

```javascript
let str = "Hello world! Hello everyone!";
let newStr = str.replaceAll("Hello", "Hi");
console.log(newStr); // 输出 "Hi world! Hi everyone!"
```

### 方法三：使用 `split` 和 `join` 方法

你可以使用 `split` 方法将字符串分割成数组，然后使用 `join` 方法将它们重新连接起来，中间插入新的子串。

```javascript
let str = "Hello world! Hello everyone!";
let newStr = str.split("Hello").join("Hi");
console.log(newStr); // 输出 "Hi world! Hi everyone!"
```

### 方法四：使用自定义函数

你也可以编写一个自定义函数来替换所有子串。

```javascript
function replaceAll(str, find, replace) {
  return str.split(find).join(replace);
}

let str = "Hello world! Hello everyone!";
let newStr = replaceAll(str, "Hello", "Hi");
console.log(newStr); // 输出 "Hi world! Hi everyone!"
```

### 注意事项

1. **区分大小写**：上述方法区分大小写。如果需要不区分大小写的替换，可以使用正则表达式并添加 `i` 标志。
   
   ```javascript
   let str = "Hello world! hello everyone!";
   let newStr = str.replace(/hello/gi, "Hi");
   console.log(newStr); // 输出 "Hi world! Hi everyone!"
   ```

2. **特殊字符**：如果要替换的子串中包含特殊字符（如正则表达式中的元字符），需要对这些字符进行转义。

   ```javascript
   function escapeRegExp(string) {
     return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& 表示整个匹配项
   }

   let str = "Hello. How are you? Hello!";
   let newStr = str.replace(new RegExp(escapeRegExp("Hello."), 'g'), "Hi");
   console.log(newStr); // 输出 "Hi How are you? Hi!"
   ```

3. **浏览器兼容性**：`replaceAll` 方法在较旧的浏览器中可能不受支持，使用前需检查浏览器兼容性或采用其他替代方法。

通过这些方法，你可以灵活地在 JavaScript 中替换字符串中的所有子串。

## css 如何匹配前N个子元素及最后N个子元素
CSS 提供了几种方法来匹配前 N 个子元素和最后 N 个子元素。主要可以使用 `:nth-child()`, `:nth-last-child()`, 和一些其他的伪类选择器。以下是一些常用的方法：

### 匹配前 N 个子元素

1. **使用 `:nth-child()`**

   ```css
   /* 匹配前 3 个子元素 */
   .parent > :nth-child(-n+3) {
     /* 样式 */
   }
   ```

   这里 `-n+3` 表示选择前 3 个元素。你可以根据需要更改数字。

2. **使用 `:nth-child()` 和 `:not()`**

   ```css
   /* 匹配前 3 个子元素 */
   .parent > :not(:nth-child(n+4)) {
     /* 样式 */
   }
   ```

   这里 `:not(:nth-child(n+4))` 表示不选择第 4 个及之后的元素，即选择前 3 个。

### 匹配最后 N 个子元素

1. **使用 `:nth-last-child()`**

   ```css
   /* 匹配最后 3 个子元素 */
   .parent > :nth-last-child(-n+3) {
     /* 样式 */
   }
   ```

   `-n+3` 从最后一个元素开始计数，选择最后 3 个。

2. **使用 `:nth-last-child()` 和 `:not()`**

   ```css
   /* 匹配最后 3 个子元素 */
   .parent > :not(:nth-last-child(n+4)) {
     /* 样式 */
   }
   ```

   这里选择除了从末尾数第 4 个开始的所有元素，即最后 3 个。

### 其他常用选择器

1. **第一个子元素**

   ```css
   .parent > :first-child {
     /* 样式 */
   }
   ```

2. **最后一个子元素**

   ```css
   .parent > :last-child {
     /* 样式 */
   }
   ```

3. **唯一的子元素**

   ```css
   .parent > :only-child {
     /* 样式 */
   }
   ```

### 示例

假设我们有一个列表，想要给前 3 个项目和最后 2 个项目不同的样式：

```html
<ul class="my-list">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
  <li>Item 4</li>
  <li>Item 5</li>
  <li>Item 6</li>
  <li>Item 7</li>
</ul>
```

CSS:

```css
/* 前 3 个项目 */
.my-list > li:nth-child(-n+3) {
  color: blue;
}

/* 最后 2 个项目 */
.my-list > li:nth-last-child(-n+2) {
  color: red;
}
```

### 注意事项

1. **性能考虑**：虽然这些选择器非常强大，但在处理大量元素时可能会影响性能。在这种情况下，考虑使用类来标记特定元素可能更有效。

2. **浏览器兼容性**：大多数现代浏览器都支持这些选择器，但在使用时最好检查目标浏览器的兼容性。

3. **组合使用**：这些选择器可以与其他选择器组合使用，以创建更复杂的选择规则。

4. **计数从 1 开始**：在这些选择器中，元素的计数是从 1 开始的，而不是从 0 开始。

通过灵活运用这些选择器，你可以精确地控制特定位置子元素的样式，而无需修改 HTML 结构或添加额外的类。

## 如何使用 CSS 实现网站的暗黑模式 (Dark Mode)
实现网站的暗黑模式（Dark Mode）可以通过多种方式来实现，主要包括使用 CSS 变量、媒体查询以及 JavaScript 来切换模式。以下是一些常见的方法和步骤：

### 方法一：使用 CSS 变量

使用 CSS 变量来定义颜色，然后通过切换 CSS 类来实现暗黑模式。

#### 1. 定义 CSS 变量

首先，在全局样式中定义一些 CSS 变量，用于存储颜色值。

```css
:root {
  --background-color: #ffffff;
  --text-color: #000000;
}

.dark-mode {
  --background-color: #121212;
  --text-color: #ffffff;
}
```

#### 2. 使用 CSS 变量

在你的样式中使用这些变量。

```css
body {
  background-color: var(--background-color);
  color: var(--text-color);
}
```

#### 3. 切换模式

使用 JavaScript 切换 `dark-mode` 类。

```html
<button id="toggle-dark-mode">Toggle Dark Mode</button>

<script>
  const toggleButton = document.getElementById('toggle-dark-mode');
  toggleButton.addEventListener('click', () => {
    document.documentElement.classList.toggle('dark-mode');
  });
</script>
```

### 方法二：使用媒体查询

使用 CSS 媒体查询 `prefers-color-scheme` 来自动检测用户的系统设置，并应用相应的样式。

#### 1. 定义默认样式

```css
body {
  background-color: #ffffff;
  color: #000000;
}
```

#### 2. 定义暗黑模式样式

```css
@media (prefers-color-scheme: dark) {
  body {
    background-color: #121212;
    color: #ffffff;
  }
}
```

### 方法三：结合媒体查询和手动切换

结合媒体查询和手动切换，允许用户在系统设置和手动切换之间进行选择。

#### 1. 定义 CSS 变量和媒体查询

```css
:root {
  --background-color: #ffffff;
  --text-color: #000000;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background-color: #121212;
    --text-color: #ffffff;
  }
}

body {
  background-color: var(--background-color);
  color: var(--text-color);
}

.dark-mode {
  --background-color: #121212;
  --text-color: #ffffff;
}
```

#### 2. 使用 JavaScript 切换模式

```html
<button id="toggle-dark-mode">Toggle Dark Mode</button>

<script>
  const toggleButton = document.getElementById('toggle-dark-mode');
  toggleButton.addEventListener('click', () => {
    document.documentElement.classList.toggle('dark-mode');
  });
</script>
```

### 方法四：使用 Local Storage 记住用户选择

使用 Local Storage 记住用户的选择，并在页面加载时应用。

#### 1. 修改 JavaScript 代码

```html
<button id="toggle-dark-mode">Toggle Dark Mode</button>

<script>
  const toggleButton = document.getElementById('toggle-dark-mode');

  // 检查 Local Storage 中的设置
  if (localStorage.getItem('theme') === 'dark') {
    document.documentElement.classList.add('dark-mode');
  }

  toggleButton.addEventListener('click', () => {
    document.documentElement.classList.toggle('dark-mode');
    // 保存用户选择到 Local Storage
    if (document.documentElement.classList.contains('dark-mode')) {
      localStorage.setItem('theme', 'dark');
    } else {
      localStorage.setItem('theme', 'light');
    }
  });
</script>
```

### 总结

通过以上几种方法，你可以轻松地在网站中实现暗黑模式。使用 CSS 变量可以使样式更加灵活和可维护，而媒体查询可以自动适应用户的系统设置。结合 JavaScript 和 Local Storage，可以提供更好的用户体验，允许用户在暗黑模式和亮色模式之间自由切换并记住他们的选择。

## 简单介绍 requestIdleCallback 及使用场景
`requestIdleCallback` 是一个浏览器 API，它允许开发者在浏览器的空闲时间执行低优先级的任务，而不会影响关键的渲染和交互任务。这个 API 的主要目的是提高网页的性能和响应性，通过在浏览器空闲时执行非关键任务来避免阻塞主线程。

### 基本用法

```javascript
requestIdleCallback(callback[, options]);
```

- `callback`: 在空闲时期被调用的函数。
- `options`: 可选参数，包含 `timeout` 属性，指定回调函数最晚应该在多少毫秒内被调用。

### 工作原理

1. 浏览器在完成关键任务（如渲染、事件处理）后，如果有剩余时间，就会调用 `requestIdleCallback` 中的回调函数。

2. 回调函数接收一个 `IdleDeadline` 对象作为参数，这个对象包含两个重要信息：
   - `timeRemaining()`: 返回当前空闲期还剩余的毫秒数。
   - `didTimeout`: 布尔值，表示回调是否因为超时而被调用。

3. 开发者可以在回调函数中检查剩余时间，决定是否继续执行任务或将任务分割成更小的部分。

### 使用场景

1. **数据预加载**：在用户不太可能注意到的时候预加载数据或资源。

   ```javascript
   requestIdleCallback(() => {
     prefetchData();
   });
   ```

2. **延迟分析和日志记录**：执行不紧急的分析或日志记录任务。

   ```javascript
   requestIdleCallback(() => {
     sendAnalytics();
   });
   ```

3. **渐进式加载**：分批处理大量数据或 DOM 操作。

   ```javascript
   function processData(data, index) {
     requestIdleCallback((deadline) => {
       while (index < data.length && deadline.timeRemaining() > 0) {
         // 处理数据
         index++;
       }
       if (index < data.length) {
         processData(data, index);
       }
     });
   }
   ```

4. **优化长任务**：将长时间运行的任务分解成更小的部分。

   ```javascript
   function longTask(tasks) {
     requestIdleCallback((deadline) => {
       while (tasks.length > 0 && deadline.timeRemaining() > 0) {
         performTask(tasks.pop());
       }
       if (tasks.length > 0) {
         longTask(tasks);
       }
     });
   }
   ```

5. **延迟初始化**：延迟初始化不立即需要的组件或功能。

   ```javascript
   requestIdleCallback(() => {
     initNonCriticalFeatures();
   });
   ```

6. **清理和维护任务**：执行周期性的清理或维护任务。

   ```javascript
   requestIdleCallback(() => {
     cleanUpOldData();
   });
   ```

### 注意事项

1. **不要用于关键任务**：`requestIdleCallback` 不适合用于需要立即执行的关键任务。

2. **考虑超时**：设置合理的超时时间，确保任务最终会被执行。

3. **检查浏览器支持**：并非所有浏览器都支持 `requestIdleCallback`，可能需要使用 polyfill。

4. **避免过度使用**：过度使用可能会影响性能，应谨慎使用。

5. **优先级**：`requestIdleCallback` 的优先级低于 `requestAnimationFrame`，后者更适合用于动画和视觉更新。

通过合理使用 `requestIdleCallback`，开发者可以显著提高网页的性能和响应性，特别是在处理大量数据或复杂操作时。它提供了一种优雅的方式来执行非关键任务，而不会影响用户体验。

## 在 redux 中如何发送请求
在 Redux 中发送请求通常涉及使用中间件来处理异步操作。最常用的方法是使用 Redux Thunk 中间件，但也有其他选择，如 Redux Saga 或 Redux Observable。以下是使用 Redux Thunk 发送请求的基本步骤和一些常见模式：

### 1. 使用 Redux Thunk

首先，安装 Redux Thunk：

```bash
npm install redux-thunk
```

然后在创建 store 时应用这个中间件：

```javascript
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import rootReducer from './reducers';

const store = createStore(rootReducer, applyMiddleware(thunk));
```

### 2. 创建异步 Action Creator

使用 Thunk，你可以创建返回函数而不是对象的 action creators。这些函数可以执行异步操作：

```javascript
import axios from 'axios';

// 同步 action creators
const fetchDataRequest = () => ({ type: 'FETCH_DATA_REQUEST' });
const fetchDataSuccess = (data) => ({ type: 'FETCH_DATA_SUCCESS', payload: data });
const fetchDataFailure = (error) => ({ type: 'FETCH_DATA_FAILURE', payload: error });

// 异步 action creator
export const fetchData = () => {
  return async (dispatch) => {
    dispatch(fetchDataRequest());
    try {
      const response = await axios.get('https://api.example.com/data');
      dispatch(fetchDataSuccess(response.data));
    } catch (error) {
      dispatch(fetchDataFailure(error.message));
    }
  };
};
```

### 3. 在组件中使用

在 React 组件中，你可以使用 `useDispatch` hook 来调用这个 action：

```javascript
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchData } from './actions';

const MyComponent = () => {
  const dispatch = useDispatch();
  const { data, loading, error } = useSelector(state => state.data);

  useEffect(() => {
    dispatch(fetchData());
  }, [dispatch]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      {/* 渲染数据 */}
    </div>
  );
};
```

### 4. 处理请求状态

在 reducer 中处理不同的请求状态：

```javascript
const initialState = {
  data: null,
  loading: false,
  error: null
};

const dataReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'FETCH_DATA_REQUEST':
      return { ...state, loading: true };
    case 'FETCH_DATA_SUCCESS':
      return { ...state, loading: false, data: action.payload };
    case 'FETCH_DATA_FAILURE':
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
};
```

### 5. 取消请求

如果需要取消请求，可以使用 Axios 的 cancel token：

```javascript
import axios from 'axios';

export const fetchData = () => {
  return (dispatch) => {
    const source = axios.CancelToken.source();

    dispatch(fetchDataRequest());
    axios.get('https://api.example.com/data', { cancelToken: source.token })
      .then(response => dispatch(fetchDataSuccess(response.data)))
      .catch(error => {
        if (axios.isCancel(error)) {
          console.log('Request canceled:', error.message);
        } else {
          dispatch(fetchDataFailure(error.message));
        }
      });

    // 返回一个取消函数
    return () => source.cancel('Operation canceled by the user.');
  };
};
```

### 6. 使用 Redux Toolkit（推荐）

Redux Toolkit 提供了更简洁的方式来处理异步操作，使用 `createAsyncThunk`：

```javascript
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import axios from 'axios';

export const fetchData = createAsyncThunk(
  'data/fetchData',
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get('https://api.example.com/data');
      return response.data;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const dataSlice = createSlice({
  name: 'data',
  initialState: { data: null, loading: false, error: null },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchData.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchData.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(fetchData.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});
```

这种方法简化了 action 创建和 reducer 逻辑，使代码更加简洁和易于维护。

通过这些方法，你可以在 Redux 中有效地管理 API 请求，处理加载状态、成功响应和错误情况。选择哪种方法取决于你的项目需求和个人偏好。Redux Toolkit 是官方推荐的方法，它简化了很多 Redux 相关的样板代码。

## 在 redux 中如何写一个记录状态变更的日志插件
在 Redux 中编写一个记录状态变更的日志插件，可以帮助你在开发过程中跟踪和调试应用程序的状态变化。这种插件可以在每次状态变更时记录 action 和新的状态。

### 实现一个简单的日志插件

我们可以通过编写一个 Redux 中间件来实现这个功能。以下是实现过程：

#### 1. 创建日志中间件

```javascript
const logger = store => next => action => {
  console.group(action.type);
  console.log('Previous State:', store.getState());
  console.log('Action:', action);
  const result = next(action);
  console.log('Next State:', store.getState());
  console.groupEnd();
  return result;
};

export default logger;
```

#### 2. 在 Redux Store 中应用中间件

使用 `applyMiddleware` 将日志中间件应用到 Redux store 中：

```javascript
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import logger from './middlewares/logger';
import rootReducer from './reducers';

const store = createStore(
  rootReducer,
  applyMiddleware(thunk, logger) // 将 logger 添加到中间件列表中
);

export default store;
```

### 解释代码

- **`logger` 中间件**：这是一个简单的日志中间件，它在每次 action 被派发时执行。它使用 `console.group` 来将日志信息分组，使输出更清晰。
- **`store.getState()`**：获取当前的 Redux 状态。
- **`next(action)`**：将 action 传递给下一个中间件或 reducer。
- **`console.log`**：记录上一个状态、action 和下一个状态。

### 使用 Redux Toolkit

如果你使用 Redux Toolkit，你可以将日志中间件添加到 `configureStore` 中：

```javascript
import { configureStore } from '@reduxjs/toolkit';
import logger from './middlewares/logger';
import rootReducer from './reducers';

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),
});

export default store;
```

### 自定义日志格式

你可以根据需要自定义日志格式，记录额外的信息或以不同的方式格式化输出。例如，添加时间戳或在生产环境中禁用日志：

```javascript
const logger = store => next => action => {
  const timestamp = new Date().toISOString();
  console.group(`[${timestamp}] ${action.type}`);
  console.log('Previous State:', store.getState());
  console.log('Action:', action);
  const result = next(action);
  console.log('Next State:', store.getState());
  console.groupEnd();
  return result;
};

export default logger;
```

### 在生产环境中禁用日志

确保日志中间件仅在开发环境中启用，可以在中间件中检查环境变量：

```javascript
const logger = store => next => action => {
  if (process.env.NODE_ENV !== 'production') {
    const timestamp = new Date().toISOString();
    console.group(`[${timestamp}] ${action.type}`);
    console.log('Previous State:', store.getState());
    console.log('Action:', action);
    const result = next(action);
    console.log('Next State:', store.getState());
    console.groupEnd();
    return result;
  }
  return next(action);
};

export default logger;
```

### 完整示例

```javascript
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import rootReducer from './reducers';

// 日志中间件
const logger = store => next => action => {
  if (process.env.NODE_ENV !== 'production') {
    const timestamp = new Date().toISOString();
    console.group(`[${timestamp}] ${action.type}`);
    console.log('Previous State:', store.getState());
    console.log('Action:', action);
    const result = next(action);
    console.log('Next State:', store.getState());
    console.groupEnd();
    return result;
  }
  return next(action);
};

// 创建 store 并应用中间件
const store = createStore(
  rootReducer,
  applyMiddleware(thunk, logger)
);

export default store;
```

通过这种方式，你可以在 Redux 中实现一个记录状态变更的日志插件，帮助你更好地调试和开发应用程序。