## 什么是 Data URL
Data URL（数据统一资源定位符）是一种统一资源标识符（URL）方案，用于将小文件嵌入到文档中，而不必引用外部文件。Data URL 允许将数据内联直接放在 URL 中，以便在需要时可以直接使用。

Data URL 的一般语法如下：

```
data:[<mediatype>][;base64],<data>
```

- `<mediatype>` 是数据的 MIME 类型（例如，image/png、text/plain 等），可选。
- `;base64` 是一个可选的标志，表示数据已经使用 Base64 编码。
- `<data>` 是实际的数据内容，可以是纯文本或经过 Base64 编码的数据。

## 如何自定义滚动条的样式
你可以使用 CSS 来自定义滚动条的样式。在大多数现代浏览器中，你可以使用 `::-webkit-scrollbar` 伪元素来实现这一目的。以下是一个简单的示例，展示了如何自定义滚动条的样式：

```css
/* 定义滚动条轨道 */
::-webkit-scrollbar {
  width: 12px; /* 宽度 */
}

/* 定义滚动条滑块 */
::-webkit-scrollbar-thumb {
  background-color: #888; /* 滑块颜色 */
  border-radius: 6px; /* 滑块圆角 */
}

/* 定义滚动条轨道背景 */
::-webkit-scrollbar-track {
  background-color: #f1f1f1; /* 轨道背景色 */
}
```

上述代码中，`::-webkit-scrollbar` 用于定义整个滚动条，`::-webkit-scrollbar-thumb` 用于定义滚动条滑块，`::-webkit-scrollbar-track` 用于定义滚动条轨道的背景。

需要注意的是，不同浏览器可能需要不同的前缀，比如 `-ms-` 用于 Edge 浏览器，`-moz-` 用于 Firefox 浏览器。另外，某些浏览器可能不支持自定义滚动条样式。

除了这种基本的 CSS 自定义滚动条样式外，还可以使用 JavaScript 库（如 PerfectScrollbar）或者 CSS-in-JS 库（如 styled-components）来实现更复杂的滚动条样式定制。

## 什么是 HTML 的实体编码 (HTML Entity Encode)

HTML 实体编码（HTML Entity Encode）是一种将特殊字符转换成可安全嵌入 HTML 页面的编码方式。这种编码方式主要是为了确保网页内容在传输过程中不会引起混淆或安全问题。

在 HTML 中，有一些字符具有特殊的意义，例如 `<`、`>`、`&`、`"`（引号）和 `'`（单引号）。这些字符在 HTML 标签中具有特定的用途，例如 `<` 用于开始标签，`>` 用于结束标签，`&` 用于开始实体引用。

为了防止这些字符被错误地解释为 HTML 标签的一部分，或者为了确保特殊字符在网页上正确显示，开发者会将它们转换成对应的 HTML 实体编码。

以下是一些常见的 HTML 实体编码示例：

- `&lt;` 对应 `<`（小于号）
- `&gt;` 对应 `>`（大于号）
- `&amp;` 对应 `&`（和号）
- `&quot;` 对应 `"`（双引号）
- `&apos;` 对应 `'`（单引号）
- `&nbsp;` 对应 ` `（非破折号空格）

使用实体编码的步骤通常如下：

1. 将特殊字符替换为其对应的 HTML 实体编码。
2. 将编码后的字符串嵌入到 HTML 文档中。

例如，如果你想在网页中显示一个小于号 `<`，你应该使用 `&lt;` 而不是 `<`。

实体编码不仅用于显示特殊字符，还用于处理用户输入，以避免潜在的跨站脚本（XSS）攻击。在处理用户输入时，将特殊字符编码可以防止恶意代码被注入到网页中。

以下是一个简单的例子，演示了如何使用 HTML 实体编码：

```html
<!-- 原始文本 -->
Hello, world! <a href="http://example.com">Link</a>

<!-- 使用实体编码 -->
Hello, world! &lt;a href="http://example.com"&gt;Link&lt;/a&gt;
```

在上面的例子中，`<a>` 标签和其中的 `<`、`>` 字符被编码为 `&lt;` 和 `&gt;`，以确保它们在 HTML 文档中被正确地解释为文本而不是标签。

## textarea 如何禁止拉伸
要禁止 `<textarea>` 元素的拉伸，你可以使用 CSS 样式属性 `resize`。`resize` 属性允许你控制 `<textarea>` 元素的大小调整行为。

默认情况下，`resize` 属性的值为 `both`，允许用户在水平和垂直方向上调整 `<textarea>` 的大小。如果你想禁止用户调整 `<textarea>` 的大小，你可以将 `resize` 属性设置为 `none`。

以下是一个简单的示例，展示如何使用 CSS 来禁止 `<textarea>` 元素的拉伸：

```css
textarea {
    resize: none;
}
```

通过将 `resize` 属性设置为 `none`，用户将无法通过拖动边框来调整 `<textarea>` 的大小。这样可以确保 `<textarea>` 元素保持固定的大小，不会被用户意外拉伸。

如果你希望在水平或垂直方向上允许调整大小，你可以将 `resize` 属性设置为 `horizontal` 或 `vertical`，以允许用户在相应方向上调整 `<textarea>` 的大小。

## 在 Canvas 中如何处理跨域的图片
在 Canvas 中处理跨域的图片涉及到跨域资源共享（CORS）策略。当你尝试在 Canvas 中绘制来自不同域的图片时，可能会遇到跨域问题。以下是一些处理跨域图片的方法：

1. **服务器端设置 CORS 头**:
   如果你有控制权，可以在提供图片的服务器端设置 CORS 头来允许跨域访问。在响应头中添加 `Access-Control-Allow-Origin` 头，允许特定域或所有域访问资源。

2. **使用代理**:
   可以设置一个代理服务器，将跨域的图片请求转发到同源请求，然后将响应返回给 Canvas。这种方法需要在代理服务器上进行处理，以确保跨域图片能够正常加载。

3. **将图片转换为 Base64 编码**:
   将跨域的图片转换为 Base64 编码，然后将其作为数据 URI 直接传递给 Canvas。这样可以避免跨域问题，因为数据 URI 是同源的。

示例代码如下：

```javascript
// 创建一个 Image 对象
var img = new Image();

// 设置图片的 src（跨域图片）
img.src = 'https://example.com/image.jpg';

// 图片加载完成后绘制到 Canvas
img.onload = function() {
    var canvas = document.getElementById('myCanvas');
    var ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
};
```

需要注意的是，以上方法中，最好的做法是在服务器端设置 CORS 头来允许跨域访问，这是最安全和可靠的方法。如果无法控制服务器端，可以考虑其他方法来处理跨域图片。

## 如何实现容器中子元素三个三列布局，子元素两个则两列布局
如果你希望实现一个简单的布局，当子元素数量为 2 时显示两列布局，子元素数量为 3 时显示三列布局，你可以使用 Flexbox 来实现。在这种情况下，你可以设置前三个子元素的 `flex` 属性为 `1`，使它们平均占据父容器的空间，从而实现三列布局。剩下的子元素将默认占据一行，实现两列布局。

下面是一个示例代码：

```html
<div class="container">
  <div class="item">1</div>
  <div class="item">2</div>
  <div class="item">3</div>
  <!-- 可以根据需要添加更多子元素 -->
</div>
```

```css
.container {
  display: flex;
  flex-wrap: wrap;
}

.item {
  flex: 1; /* 所有子元素平均占据父容器的空间 */
}

.item:nth-child(n+4) {
  flex: 0 0 100%; /* 第四个及之后的子元素占据整行 */
}

/* 可以根据需要添加样式以适应布局需求 */
```

在上面的示例中，我们将父容器 `.container` 设置为 Flex 容器，并且设置子元素 `.item` 的 `flex` 属性为 `1`，使前三个子元素平均占据父容器的空间，实现三列布局。对于第四个及之后的子元素，我们将其 `flex` 属性设置为 `0 0 100%`，使其占据整行，实现两列布局。

这样，无论子元素数量为 2 或 3，都可以根据你的需求显示不同列数的布局。

## 前端上传文件时如何读取文件内容
前端上传文件时读取文件内容，主要依赖于 HTML 的 `<input type="file">` 元素和 的 File API。

以下是一个简单的示例代码：

```html
<!DOCTYPE html>
<html>
<head>
  <title>文件上传示例</title>
</head>
<body>

  <input type="file" id="fileInput" accept=".txt">
  <button id="uploadBtn">上传</button>
  <div id="result"></div>

  <script>
    const fileInput = document.('fileInput');
    const uploadBtn = document.('uploadBtn');
    const result = document.('result');

    uploadBtn.('click', () => {
      const file = fileInput.files[0];
      if (file) {
        const reader = new();
        reader.onload = (e) => {
          result. = e.target.result;
        };
        reader.readAsText(file); // 读取文件内容为文本
      }
    });
  </script>

</body>
</html>
```

**代码解释：**

1.  **HTML:**
    *   `<input type="file" id="fileInput" accept=".txt">`: 创建一个文件选择框，允许用户选择文件，并指定接受的文件类型为 `.txt`。
    *   `<button id="uploadBtn">上传</button>`: 创建一个按钮，触发文件上传操作。
    *   `<div id="result"></div>`: 用于显示文件内容的容器。

2.  **JavaScript:**
    *   获取文件选择框、按钮和结果容器的 DOM 元素。
    *   给按钮添加事件监听器，当按钮被点击时执行以下操作：
        *   获取选中的文件，第一个文件用 `fileInput.files[0]` 获取。
        *   如果文件存在， `FileReader` 对象。
        *   设置 `FileReader` 对象的 `onload` 事件处理程序，当文件读取完成时执行该函数，并将读取到的文件内容显示在 `result` 容器中。
        *   使用 `readAsText(file)` 方法读取文件内容为文本。

**注意：**

*   `FileReader` 对象提供了一种异步读取文件内容的方式，`onload` 事件处理程序会在文件读取完成后执行。
*   你可以根据需要修改 `readAsText()` 方法为 `readAsDataURL()` 或 `readAsArrayBuffer()`，读取文件内容为数据URL或二进制数组。
*   在实际应用中，你需要根据你的应用场景进行修改，例如处理文件类型验证、文件上传验证等。

## 网站设置字体时，如何设置优先使用系统默认字体
font-family: system-ui;
system-ui 将会自动选取系统默认字体作为字体

## 如何实现一个函数 lodash.merge
`lodash.merge` 函数用于将多个对象的属性合并到第一个对象中。如果属性值是对象，则会递归合并。以下是一个简单的实现示例：

```javascript
function merge(target, ...sources) {
    for (const source of sources) {
        for (const key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                if (typeof source[key] === 'object' && source[key] !== null) {
                    // 如果属性值是对象，则递归合并
                    target[key] = merge({}, target[key], source[key]);
                } else {
                    // 否则直接赋值
                    target[key] = source[key];
                }
            }
        }
    }
    return target;
}

// 示例
const obj1 = {
    a: 1,
    b: {
        c: 2
    }
};

const obj2 = {
    b: {
        d: 3
    },
    e: 4
};

const merged = merge({}, obj1, obj2);
console.log(merged);
```

在这个示例中，`merge` 函数接受一个目标对象 `target` 和多个源对象 `sources`。它遍历每个源对象的属性，并将其合并到目标对象中。如果属性值是对象，则会递归调用 `merge` 函数进行合并。最后返回合并后的目标对象。

需要注意的是，这只是一个简单的示例实现，实际的 `lodash.merge` 函数可能包含更多的功能和边界情况的处理。如果需要更完整和健壮的 `lodash.merge` 函数，建议直接使用 lodash 库或者查看其源码以获取更多细节。

## 如何实现一个 promise.any
`Promise.any` 是一个 ES2021 引入的新方法，用于接收多个 Promise 对象并返回一个新的 Promise 对象。这个新的 Promise 对象在传入的 Promise 中有一个变为 resolved 状态时就会变为 resolved 状态，如果所有传入的 Promise 都变为 rejected 状态，则这个新的 Promise 对象也会变为 rejected 状态。以下是一个简单的 `Promise.any` 实现示例：

```javascript
function promiseAny(promises) {
    return new Promise((resolve, reject) => {
        let errors = [];
        let completed = 0;

        for (let i = 0; i < promises.length; i++) {
            promises[i].then(resolve)
                .catch(error => {
                    errors.push(error);
                    completed++;

                    if (completed === promises.length) {
                        reject(errors);
                    }
                });
        }
    });
}

// 示例
const promise1 = new Promise((resolve, reject) => setTimeout(() => reject('Promise 1 rejected'), 1000));
const promise2 = new Promise((resolve, reject) => setTimeout(() => resolve('Promise 2 resolved'), 500);
const promise3 = new Promise((resolve, reject) => setTimeout(() => reject('Promise 3 rejected'), 1500));

promiseAny([promise1, promise2, promise3])
    .then(result => console.log('Resolved:', result))
    .catch(errors => console.log('All rejected:', errors));
```

在这个示例中，`promiseAny` 函数接受一个 Promise 数组 `promises`，并返回一个新的 Promise 对象。它遍历传入的 Promise 数组，对每个 Promise 调用 `then` 方法并在其中处理 resolved 状态和 catch 方法中处理 rejected 状态。当有一个 Promise 变为 resolved 状态时，调用 `resolve` 方法；当所有 Promise 都变为 rejected 状态时，调用 `reject` 方法并传递一个包含所有错误的数组。

需要注意的是，这只是一个简单的示例实现，实际的 `Promise.any` 方法可能包含更多的功能和边界情况的处理。如果需要更完整和健壮的 `Promise.any` 实现，建议查看相关的 polyfill 或者库。

## 如何实现一个 Promise.all
`Promise.all` 是一个常见的 Promise 方法，用于接收多个 Promise 对象并返回一个新的 Promise 对象。这个新的 Promise 对象在传入的所有 Promise 都变为 resolved 状态时才会变为 resolved 状态，如果有一个 Promise 变为 rejected 状态，则这个新的 Promise 对象也会变为 rejected 状态。以下是一个简单的 `Promise.all` 实现示例：

```javascript
function promiseAll(promises) {
    return new Promise((resolve, reject) => {
        let results = [];
        let completed = 0;

        for (let i = 0; i < promises.length; i++) {
            promises[i].then(result => {
                results[i] = result;
                completed++;

                if (completed === promises.length) {
                    resolve(results);
                }
            }).catch(reject);
        }
    });
}

// 示例
const promise1 = new Promise((resolve, reject) => setTimeout(() => resolve('Promise 1 resolved'), 1000));
const promise2 = new Promise((resolve, reject) => setTimeout(() => resolve('Promise 2 resolved'), 500);
const promise3 = new Promise((resolve, reject) => setTimeout(() => resolve('Promise 3 resolved'), 1500));

promiseAll([promise1, promise2, promise3])
    .then(results => console.log('All resolved:', results))
    .catch(error => console.log('One or more promises rejected:', error));
```

在这个示例中，`promiseAll` 函数接受一个 Promise 数组 `promises`，并返回一个新的 Promise 对象。它遍历传入的 Promise 数组，对每个 Promise 调用 `then` 方法处理 resolved 状态和 catch 方法处理 rejected 状态。当所有 Promise 都变为 resolved 状态时，调用 `resolve` 方法并传递一个包含所有结果的数组；如果有一个 Promise 变为 rejected 状态，则调用 `reject` 方法。

需要注意的是，这只是一个简单的示例实现，实际的 `Promise.all` 方法可能包含更多的功能和边界情况的处理。如果需要更完整和健壮的 `Promise.all` 实现，建议查看相关的 polyfill 或者库。

## CSS 如何设置方格背景
要在 CSS 中设置方格背景，可以借助 CSS 的 `background-image` 属性和 `repeating-linear-gradient` 函数来实现。下面是一个示例，展示如何创建一个方格背景：

```css
.square-grid {
    width: 200px; /* 设置容器宽度 */
    height: 200px; /* 设置容器高度 */
    background-image: repeating-linear-gradient(0deg, transparent, transparent 10px, black 10px, black 20px); /* 创建方格背景 */
}
```

在这个示例中，我们创建了一个名为 `square-grid` 的容器，并设置了它的宽度和高度。然后，通过 `background-image` 属性和 `repeating-linear-gradient` 函数创建了一个方格背景。`repeating-linear-gradient` 函数用于创建一个重复的线性渐变背景，我们设置了每个方格的高度为 20px，其中前 10px 是透明的，后 10px 是黑色的，从而形成了方格的效果。

你可以根据需要调整 `width`、`height` 和渐变的颜色、大小来定制方格背景。这种方法是使用 CSS 创建简单方格背景的一种方式，可以根据具体需求进行进一步的定制和调整。

## 如何取消请求的发送

取消请求的发送取决于你使用的请求方法和库。以下是一些常见情况下如何取消请求发送的方法：

### 对于 `XMLHttpRequest`：

你可以使用 `abort` 方法来取消请求：

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', 'your-url', true);

xhr.onreadystatechange = function () {
    if (xhr.readyState == XMLHttpRequest.DONE) {
        // 请求已完成
    }
};

xhr.send(); // 发送请求

// 要取消请求
xhr.abort();
```

### 对于 `fetch` API：

`fetch` 返回一个 Promise，你可以使用 `Promise` 的 `finally` 方法来执行一些清理操作，包括取消请求。但是，`fetch` 本身并不提供直接取消请求的方法。一种常见的做法是使用一个取消令牌（cancellation token）：

```javascript
let controller = new AbortController();
let { signal } = controller;

fetch('your-url', { signal })
    .then(response => {
        // 处理响应
    })
    .catch(error => {
        if (error.name === 'AbortError') {
            console.log('Fetch aborted');
        } else {
            // 处理其他错误
        }
    });

// 要取消请求
controller.abort();
```

### 对于 `axios`：

`axios` 提供了一个取消令牌（cancellation token）来取消请求：

```javascript
const CancelToken = axios.CancelToken;
let cancel;

axios.get('your-url', {
    cancelToken: new CancelToken(function executor(c) {
        // executor 函数接收一个取消函数作为参数
        cancel = c;
    })
})
.then(response => {
    // 处理响应
})
.catch(error => {
    if (axios.isCancel(error)) {
        console.log('Request canceled', error.message);
    } else {
        // 处理其他错误
    }
});

// 要取消请求
cancel();
```

在使用这些方法时，请确保在适当的时机取消请求，例如在组件卸载、用户离开页面或者你确定不再需要响应时。这有助于避免不必要的网络请求和潜在的资源浪费。

## 如何过滤数组中的 falsy value
要过滤数组中的假值（falsy values），可以使用 JavaScript 中的 `filter` 方法结合布尔转换来实现。假值包括 `false`、`null`、`0`、`""`、`undefined` 和 `NaN`。以下是一个简单的示例：

```javascript
const arr = [0, 1, false, 2, '', 3, null, undefined, NaN, 4];

const filteredArr = arr.filter(Boolean);
console.log(filteredArr); // 输出 [1, 2, 3, 4]
```

在这个示例中，我们使用 `filter` 方法并传入 `Boolean` 函数作为参数。`Boolean` 函数会将数组中的每个元素转换为布尔值，然后 `filter` 方法会过滤掉值为假的元素，返回一个新的数组。

这种方法非常简洁且易于理解，它利用了 JavaScript 中布尔转换的特性。如果数组中的元素为假值，那么在布尔上下文中它们会被视为 `false`，因此会被 `filter` 方法排除掉。

## React.setState 是同步还是异步的
在 React 中，`setState` 并不是同步的，而是异步的。这意味着在调用 `setState` 后，不能立即假设状态已经被更新。React 会将多个 `setState` 调用合并为单个更新，以提高性能并避免不必要的重新渲染。

当你调用 `setState` 时，React 将安排更新并在稍后的时间进行批处理。这意味着你不能依赖于立即的状态更改，因为 `setState` 调用后立即访问状态可能会得到旧的状态值。

如果你需要在状态更新后执行某些操作，可以使用 `setState` 的回调函数或者在 `componentDidUpdate` 生命周期方法中进行操作。例如：

```javascript
this.setState({ count: this.state.count + 1 }, () => {
  // 这里可以放置在状态更新后需要执行的代码
});
```

或者在 `componentDidUpdate` 中：

```javascript
componentDidUpdate(prevProps, prevState) {
  if (this.state.someValue !== prevState.someValue) {
    // 在状态更新后执行的操作
  }
}
```

这种异步的 `setState` 设计有助于提高性能，并且可以更好地控制组件的更新行为。

## 在 React 中如何实现代码分割 (code splitting)
在 React 中，你可以使用动态 `import()` 函数或 React.lazy 与 Suspense 组件来实现代码分割（code splitting）。代码分割可以帮助减小初始加载的页面大小，提高应用的性能，因为它允许你按需加载代码块而不是一次性加载整个应用程序。

### 使用动态 `import()`

```javascript
const SomeComponent = React.lazy(() => import('./SomeComponent'));

function MyComponent() {
  return (
    <div>
      <React.Suspense fallback={<div>Loading...</div>}>
        <SomeComponent />
      </React.Suspense>
    </div>
  );
}
```

在这个例子中，`React.lazy` 接受一个函数，这个函数返回一个动态加载的模块。当 `SomeComponent` 首次渲染时，React 将开始加载 `SomeComponent`。`React.Suspense` 组件用于在加载过程中显示一个加载指示器，直到加载完成。

### 使用动态 `import()` 和 `Promise`

```javascript
import React, { Suspense } from 'react';

class MyComponent extends React.Component {
  state = {
    component: null
  };

  componentDidMount() {
    import('./SomeComponent').then(component => {
      this.setState({ component: component.default });
    });
  }

  render() {
    const { component: Component } = this.state;
    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          {Component && <Component />}
        </Suspense>
      </div>
    );
  }
}
```

在这个例子中，我们在组件挂载后使用动态 `import()` 来加载 `SomeComponent`。一旦加载完成，我们将其放入状态中，并在渲染时使用 `Suspense` 组件来展示加载指示器，直到组件加载完成。

以上两种方法都可以实现代码分割，你可以根据自己的偏好和项目需求选择其中之一。

https://zh-hans.legacy.reactjs.org/docs/code-splitting.html

## 在 React 中如何做好性能优化
在 React 中，有许多方法可以用来优化性能，以下是一些常见的技术和最佳实践：

1. **代码分割（Code Splitting）**：使用动态 `import()` 或 React.lazy 和 Suspense 组件来按需加载组件，减小初始加载大小。

2. **组件优化**：
   - **PureComponent 和 shouldComponentUpdate**：使用 `PureComponent` 或手动实现 `shouldComponentUpdate` 来避免不必要的重新渲染。
   - **Memoization**：使用 `useMemo` 和 `useCallback` 来缓存计算结果，避免重复计算。

3. **虚拟化列表**：对于长列表，使用虚拟化技术（如 react-virtualized 或 react-window）来减少 DOM 元素数量，提高性能。

4. **事件处理**：避免在 render 方法中创建新的函数引用，可以在构造函数中绑定事件处理程序或使用箭头函数。

5. **减少不必要的渲染**：
   - **React.memo**：对于函数式组件，使用 `React.memo` 来缓存组件。
   - **useEffect 优化**：使用依赖数组来控制 `useEffect` 的触发条件，避免不必要的副作用。

6. **使用 Production 模式**：在生产环境中使用 React 的生产版本，以减少开发时的调试信息和优化性能。

7. **Webpack 优化**：通过 Webpack 的优化配置（如代码拆分、压缩、懒加载等）来提高应用性能。

8. **图片优化**：使用适当大小和格式的图片，并考虑懒加载图片以减少初始加载时间。

9. **状态管理**：合理使用状态管理工具（如 Redux、Context API），避免过度使用全局状态。

10. **Bundle 分析**：使用工具（如 webpack-bundle-analyzer）来分析打包后的 bundle，找出优化的潜在方向。

这些技术和最佳实践可以帮助你提高 React 应用的性能，但具体的优化策略应根据项目需求和特点进行调整和优化。

## Core Web Vitals 是什么，它有哪些指标

Core Web Vitals 是谷歌推出的一套用于衡量网站性能的关键指标。这些指标对于改善用户体验和搜索引擎优化（SEO）都非常重要。以下是 Core Web Vitals 的主要指标：

1. **Largest Contentful Paint (LCP)**：
   - **定义**：LCP 衡量的是页面上的主要内容（图像、视频等）加载完成所需的时间。
   - **重要性**：它反映了用户等待页面主要内容加载的时间，是衡量页面加载性能的关键指标。
   - **目标**：理想情况下，LCP 应该发生在页面加载的前 2.5 秒内。

2. **First Input Delay (FID)**：
   - **定义**：FID 衡量的是用户首次与页面互动（如点击、滑动等）到浏览器开始响应该交互所需的时间。
   - **重要性**：它反映了用户交互的响应速度，是衡量交互性能的关键指标。
   - **目标**：理想情况下，FID 应该小于 100 毫秒。

3. **Cumulative Layout Shift (CLS)**：
   - **定义**：CLS 衡量的是页面在加载过程中元素位置发生变化的程度。
   - **重要性**：它反映了页面的稳定性，即用户在阅读内容时页面元素是否突然移动。
   - **目标**：理想情况下，CLS 应该小于 0.1。

### 其他相关指标：

虽然不是 Core Web Vitals 的直接指标，但以下指标也对用户体验和性能有重要影响：

- **Time to Interactive (TTI)**：衡量页面从完全加载到可以响应用户交互所需的时间。
- **First Contentful Paint (FCP)**：衡量页面上的第一个非空白内容渲染所需的时间。

为了监控和优化这些指标，可以使用 Google 的 PageSpeed Insights 工具，它提供了对网站性能的详细分析，包括 Core Web Vitals 的得分和建议的改进措施。通过关注这些指标，网站开发者可以显著提升用户的浏览体验。

## dependencies 与 devDependencies 有何区别
在 Node.js 项目中，通常会在 package.json 文件中定义两种类型的依赖：dependencies 和 devDependencies。

### dependencies：
这是项目运行时所需的依赖项，也就是生产环境下需要的依赖包。这些依赖项通常包括应用程序运行所需的库、框架和工具。当用户通过 npm install 安装项目时，这些依赖项会被安装。

### devDependencies：
这是开发过程中所需的依赖项，也就是开发环境下需要的依赖包。这些依赖项通常包括测试框架、构建工具、代码检查工具等，这些工具在项目部署后并不需要。当用户通过 npm install --only=dev 或 npm install --dev 安装项目时，这些依赖项会被安装。

### 区别总结：
1. **dependencies** 是项目运行时所需的依赖，而 **devDependencies** 是开发过程中所需的依赖。
2. 当用户通过 npm install 安装项目时，**dependencies** 和 **devDependencies** 两者的依赖项都会被安装。
3. 当用户通过 npm install --only=dev 或 npm install --dev 安装项目时，只会安装 **devDependencies** 中的依赖项。

这种区分允许开发者在项目部署时只安装必要的生产依赖，从而减少部署包的大小，同时也方便开发者在开发环境中使用必要的开发工具和依赖。

## npm workspaces 解决了什么问题
npm workspaces 是 npm 的一个功能，允许你在一个单独的根项目中管理多个相关的包（packages）。这个功能解决了一些常见的问题：

1. **多包管理**：当一个项目由多个相关的包组成时，通常需要分别管理每个包的依赖关系和版本。npm workspaces 可以让你在一个统一的环境下管理这些包，简化了多包项目的管理。

2. **依赖管理**：通过 npm workspaces，可以在根项目中统一管理依赖，避免了多个包中重复安装相同的依赖，提高了依赖的共享和重用性。

3. **版本管理**：npm workspaces 允许你在根项目中统一管理包的版本，避免了不同包使用不一致的依赖版本的问题。

4. **命令统一**：通过 npm workspaces，你可以使用一致的命令来管理所有的包，例如统一安装依赖、运行脚本等。

5. **开发流程优化**：对于需要同时修改多个相关包的开发者来说，npm workspaces 提供了便利，可以在一个命令下对所有包进行操作，简化了开发流程。

总的来说，npm workspaces 解决了多包项目中依赖、版本和管理的复杂性，提供了一种更加统一和便捷的方式来管理和开发多包项目。

## 如何检测并避免循环依赖

循环依赖是项目中常见的问题，它发生在两个或多个模块之间存在直接的或间接的依赖关系，导致它们相互引用。以下是一些检测和避免循环依赖的方法：

### 检测循环依赖：

1. **静态分析工具**：
   - 使用像 `tslint`、`eslint`、`mocha`、`jest` 这样的工具，它们可以配置为在编译或测试时检测循环依赖。
   - 使用专门的包，如 `detect-cycles`，它可以在模块解析期间检测到循环依赖。

2. **手动检查**：
   - 仔细阅读代码，确保没有模块直接或间接地导入了自身。

3. **模块打包工具**：
   - 使用 Webpack、Rollup 等模块打包工具时，它们会在构建过程中报告循环依赖。

### 避免循环依赖：

1. **模块化设计**：
   - 确保每个模块只做一件事情，并且尽可能保持模块的独立性。
   - 使用高内聚、低耦合的原则设计模块。

2. **依赖注入**：
   - 使用依赖注入（DI）来提供依赖，而不是在模块内部直接创建或引用它们。

3. **明确导出**：
   - 使用 `export` 明确导出需要的外部依赖，避免隐式导出导致的循环依赖。

4. **重构代码**：
   - 如果检测到循环依赖，尝试重构代码，将共享的逻辑提取到一个单独的模块中。

5. **使用命名空间**：
   - 在某些情况下，可以通过使用命名空间来避免冲突。

6. **延迟加载**：
   - 使用动态导入（如 `import()`）和代码分割来延迟加载某些依赖，可能会减少循环依赖的可能性。

7. **模块解析规则**：
   - 了解你的构建工具或模块加载器的解析规则，并确保遵循最佳实践。

通过遵循这些最佳实践和工具的使用，可以有效地检测和避免循环依赖，从而确保项目的稳定性和可维护性。

## 什么是闭包，闭包的应用有哪些地方

闭包（Closure）是 JavaScript 中一个非常重要的概念，它指的是那些能够访问自由变量的函数。即使这些自由变量在函数创建时已经不在作用域内了，闭包仍然可以记住并访问它们。

### 闭包的定义：

- 闭包是一个函数和其周围状态（词法环境）的引用捆绑在一起形成的实体。
- 闭包可以记住并访问其创建时的作用域中的变量，即使这些变量已经离开了作用域。

### 闭包的应用：

1. **私有变量**：闭包可以用来创建私有变量，因为闭包可以访问其创建时的作用域中的变量，而这些变量不会被外部访问。

```javascript
function createCounter() {
  let count = 0;
  return function() {
    return count++;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

2. **模块化**：闭包可以用来模拟模块化，允许在函数内部创建私有变量和函数，同时对外暴露特定的接口。

```javascript
const module = (function() {
  let privateVar = 0;
  function privateFunction() {
    return ++privateVar;
  }

  return {
    publicMethod: function() {
      return privateFunction();
    }
  };
})();
console.log(module.publicMethod()); // 1
```

3. **缓存**：闭包可以用来缓存函数的结果，这样相同的输入可以多次调用同一个函数而不必重新计算。

```javascript
const memoize = (fn) => {
  let cache = {};
  return function(...args) {
    if (!cache[args]) {
      cache[args] = fn(...args);
    }
    return cache[args];
  };
};

const factorial = memoize((n) => {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
});
console.log(factorial(5)); // 120
console.log(factorial(5)); // 120 (使用缓存的结果)
```

4. **回调函数**：闭包经常用于回调函数中，尤其是在处理异步操作时，它可以保持对原始作用域的访问。

```javascript
function fetchData(callback) {
  setTimeout(() => {
    callback('Data');
  }, 1000);
}

fetchData(data => {
  console.log(data); // 'Data'
});
```

5. **事件处理**：闭包可以用来在事件处理函数中保持对上下文（如 DOM 元素）的引用。

```javascript
function MyComponent() {
  this.button = document.createElement('button');
  this.button.innerText = 'Click me';
  this.button.addEventListener('click', () => {
    console.log('Button clicked!');
  });
  document.body.appendChild(this.button);
}
```

闭包在 JavaScript 中是非常强大的工具，可以用来实现许多高级编程技巧，如模块化、缓存和事件处理等。

## 如何发布一个全局可执行命令的 npm package
要发布一个全局可执行命令的 npm package，需要遵循以下步骤：

1. **创建项目**：创建一个新的项目，并在项目中添加可执行命令。该命令应该被定义在 `bin` 属性中的可执行文件中。

```javascript
#!/usr/bin/env node
console.log('Hello, world!');
```

2. **初始化项目**：在项目根目录下运行 `npm init` 命令，以创建 `package.json` 文件。

```bash
npm init
```

3. **添加依赖**：将项目中的依赖添加到 `dependencies` 中，以便在安装时自动安装。

```bash
npm install --save <dependencies>
```

4. **添加可执行命令**：在 `package.json` 文件中的 `bin` 属性中添加可执行命令。

```json
{
  "name": "my-package",
  "version": "1.0.0",
  "bin": {
    "my-command": "./bin/my-command.js"
  }
}
```

5. **设置执行权限**：确保可执行文件具有执行权限，可以使用 `chmod` 命令来设置。

```bash
chmod +x ./bin/my-command.js
```

6. **登录 npm**：使用 `npm login` 命令登录到 npm。

```bash
npm login
```

7. **发布 package**：使用 `npm publish` 命令发布 package。

```bash
npm publish --access public
```

这样，你的 npm package 就已经发布成功了，其他人可以通过运行 `npm install -g <package-name>` 来全局安装你的 package，并在命令行中运行其中的可执行命令。

注意事项：

- `bin` 属性中的可执行文件应该使用 `#!/usr/bin/env node` 来指定执行环境为 Node.js。
- 为了避免名称冲突，建议将可执行命令的名称设置为与 package 名称不同的名称。
- 发布前要确保 package 的版本号是正确的，可以使用 `npm version` 命令来更新版本号。

## 如何为一个项目指定 node 版本号
为一个项目指定 Node.js 版本号可以使用以下两种方式：

1. **使用 `.nvmrc` 文件**：在项目根目录下创建一个名为 `.nvmrc` 的文件，并在其中指定所需的 Node.js 版本号。

例如，如果你想要使用 Node.js 14.17.3 版本，可以在 `.nvmrc` 文件中添加以下内容：

```
14.17.3
```

然后，在项目中使用 Node.js 时，可以使用 nvm 工具来自动切换到指定的版本。

2. **使用 `engines` 属性**：在 `package.json` 文件中的 `engines` 属性中指定所需的 Node.js 版本号。

例如，如果你想要使用 Node.js 14.x 版本，可以在 `package.json` 文件中添加以下内容：

```json
{
  "name": "my-project",
  "version": "1.0.0",
  "engines": {
    "node": "14.x"
  }
}
```

然后，在使用 `npm install` 安装依赖时，npm 会检查 Node.js 版本号是否符合要求，并在不符合要求时给出警告。

这两种方式都可以用来指定项目中所需的 Node.js 版本号，具体使用哪种方式取决于个人喜好和项目需求。

## package.json 中 main/module/browser/exports 字段有何区别
在 `package.json` 文件中，`main`、`module`、`browser` 和 `exports` 字段都用于指定模块的入口文件或入口点。它们的具体区别如下：

1. **`main` 字段**：`main` 字段用于指定 CommonJS 规范下的模块入口文件路径。当使用 `require()` 或 Node.js 的 `import` 语句导入模块时，会加载 `main` 字段指定的文件。

```json
{
  "main": "dist/main.js"
}
```

2. **`module` 字段**：`module` 字段用于指定 ES 模块规范下的模块入口文件路径。当使用现代构建工具（如 webpack、Rollup 等）打包项目时，会根据 `module` 字段指定的文件来进行模块的导入和优化。

```json
{
  "module": "src/index.js"
}
```

3. **`browser` 字段**：`browser` 字段用于在浏览器环境中替换模块的入口文件路径。当你的代码既要在 Node.js 环境下运行，又要在浏览器环境下运行时，可以使用 `browser` 字段来指定在浏览器环境中使用的入口文件路径。

```json
{
  "browser": "dist/browser.js"
}
```

4. **`exports` 字段**：`exports` 字段是在 Node.js 12+ 版本中引入的，用于指定模块的导出方式。它可以指定多个入口文件或模块，并根据不同的环境和导入方式来选择合适的模块导出。

```json
{
  "exports": {
    ".": {
      "import": "./src/index.js",
      "require": "./dist/main.js"
    }
  }
}
```

上述字段的使用取决于你的项目需求和使用的模块规范。在现代的前端开发中，通常使用 ES 模块规范，并使用构建工具来处理模块的导入和打包。因此，`module` 字段在很多情况下是最常用的。但是，为了兼容不同的环境和规范，可以同时指定多个字段，以便在不同的环境中正确加载模块。

## flex 布局中 order 有何作用
在 Flex 布局中，`order` 属性用于控制 Flex 容器中 Flex 项目的排列顺序。默认情况下，Flex 项目的排列顺序是根据它们在 HTML 结构中出现的顺序来决定的。但通过设置 `order` 属性，可以改变 Flex 项目的默认排列顺序，使得某个 Flex 项目出现在其他项目之前或之后。

具体来说，`order` 属性接受一个整数值，表示 Flex 项目的排列顺序。数值越小，项目越靠前；数值越大，项目越靠后。如果多个项目具有相同的 `order` 值，则它们的排列顺序将根据它们在 HTML 结构中的出现顺序来决定。

以下是一个简单的示例，展示了如何使用 `order` 属性改变 Flex 项目的排列顺序：

```html
<div class="container">
  <div class="item" style="order: 2;">Item 1</div>
  <div class="item" style="order: 1;">Item 2</div>
  <div class="item" style="order: 3;">Item 3</div>
</div>
```

在这个例子中，通过设置不同的 `order` 值，Flex 容器中的三个 Flex 项目的排列顺序被改变。`Item 2` 会在 `Item 1` 之前显示，`Item 1` 会在 `Item 3` 之前显示。

总结一下，`order` 属性在 Flex 布局中的作用是调整 Flex 项目的排列顺序，使得开发者可以更灵活地控制项目在 Flex 容器中的显示顺序。

## flex 布局中 align-content 与 align-items 有何区别
在 Flex 布局中，`align-content` 和 `align-items` 属性都用于控制 Flex 容器中的 Flex 项目在交叉轴上的对齐方式，但它们有一些区别：

1. **`align-content`**：
   - `align-content` 属性适用于多行的 Flex 容器，用于控制多行 Flex 项目在交叉轴上的对齐方式。
   - 如果 Flex 容器只有一行（即 `flex-wrap: nowrap`），`align-content` 属性不会生效。
   - `align-content` 属性可以设置的值包括：
     - `flex-start`：多行项目在交叉轴的起始位置对齐。
     - `flex-end`：多行项目在交叉轴的末尾位置对齐。
     - `center`：多行项目在交叉轴的中间位置对齐。
     - `space-between`：多行项目在交叉轴上均匀分布，首尾项目贴边。
     - `space-around`：多行项目在交叉轴上均匀分布，项目周围有相等的空间。
     - `stretch`：多行项目被拉伸以填充整个交叉轴。

2. **`align-items`**：
   - `align-items` 属性适用于单行或多行的 Flex 容器，用于控制所有 Flex 项目在交叉轴上的对齐方式。
   - `align-items` 只对单行 Flex 容器的项目有效，多行 Flex 容器的项目对齐方式由 `align-content` 控制。
   - `align-items` 属性可以设置的值包括：
     - `flex-start`：项目在交叉轴的起始位置对齐。
     - `flex-end`：项目在交叉轴的末尾位置对齐。
     - `center`：项目在交叉轴的中间位置对齐。
     - `baseline`：项目以其基线对齐。
     - `stretch`：项目被拉伸以填充整个交叉轴。

总的来说，`align-content` 控制多行 Flex 容器中的项目在交叉轴上的对齐方式，而 `align-items` 控制单行或多行 Flex 容器中所有项目在交叉轴上的对齐方式。具体使用哪个属性取决于布局需求和 Flex 容器的结构。

## 解构赋值一个数组，a 取第一项默认值为 3，c取剩下的值组成数组
要解构赋值一个数组，并且给 `a` 设置默认值为 3，同时将剩余的值组成数组赋给 `c`，你可以按照以下方式进行：

```javascript
const arr = [1, 2, 3, 4, 5];

const [a = 3, ...c] = arr;

console.log(a); // 输出: 1 (数组的第一项)
console.log(c); // 输出: [2, 3, 4, 5] (剩余的值组成的数组)
```

在这个例子中，我们首先创建了一个数组 `arr`，然后使用解构赋值将其拆解。`a = 3` 表示如果数组中有第一项的话，将其赋值给 `a`，否则 `a` 的值为默认值 3。`...c` 表示将剩余的值组成数组赋给 `c`。

运行这段代码后，`a` 的值将为数组的第一项，如果数组为空则为默认值 3，`c` 将包含剩余的值组成的数组。

## Map 与 WeakMap 有何区别
Map 和 WeakMap 是 JavaScript 中的两种不同的数据结构，它们之间有一些重要的区别：

1. **Map**：
   - `Map` 是一种键值对的集合，其中的键可以是任意类型，包括基本数据类型和对象引用。
   - `Map` 中的键是强引用，即使键不再被使用，它们仍然会阻止垃圾回收器回收相关的内存。
   - `Map` 可以使用 `size` 属性获取其键值对的数量，可以通过 `forEach` 方法遍历键值对，也可以通过 `get` 和 `set` 方法进行读取和设置操作。

```javascript
const myMap = new Map();
const key = { id: 1 };
myMap.set(key, "value");
```

2. **WeakMap**：
   - `WeakMap` 是一种特殊的 `Map`，其中的键必须是对象，并且是弱引用的，不会阻止对象被垃圾回收器回收。
   - 当只有 WeakMap 拥有对键的引用时，键才会被保留。如果没有其他引用指向键，键会被垃圾回收。
   - `WeakMap` 没有 `size` 属性，也没有提供类似 `forEach` 的方法，因为无法确保键是否已被垃圾回收。
   - `WeakMap` 主要用于在不影响垃圾回收的情况下存储额外的信息，通常用于私有属性或缓存。

```javascript
const myWeakMap = new WeakMap();
const key = { id: 1 };
myWeakMap.set(key, "value");
```

总的来说，`Map` 适用于需要存储键值对集合并希末保留所有键的情况，而 `WeakMap` 则适用于需要使用弱引用键的情况，以避免内存泄漏问题。

## 什么是 BFC
BFC 是块级格式化上下文（Block Formatting Context）的缩写，是 CSS 中的一个重要概念，用于描述块级盒子的布局规则。BFC 决定了块级盒子如何布局以及它们之间的关系。

在一个 BFC 中，块级盒子按照特定的规则进行布局，这些规则包括：
1. 内部的盒子在垂直方向上一个接一个地放置。
2. 盒子垂直方向的距离由 margin 决定，相邻盒子的 margin 会发生重叠。
3. BFC 内部的盒子不会与浮动元素重叠。
4. BFC 可以包含浮动元素，并且不会被浮动元素覆盖。

触发 BFC 的条件包括：
1. 根元素（`<html>`）或包含根元素的元素。
2. 浮动元素（`float` 不是 `none`）。
3. 绝对定位元素（`position` 为 `absolute` 或 `fixed`）。
4. 行内块元素（`display` 为 `inline-block`）。
5. 表格单元格（`display`为 `table-cell`）。
6. 表格标题（`display` 为 `table-caption`）。
7. 包含块级格式化上下文的元素（`overflow` 不为 `visible`）。

利用 BFC 可以解决一些常见的布局问题，比如清除浮动、防止 margin 重叠等。通过创建 BFC，可以控制元素的布局行为，使得页面的布局更加可控和稳定。

## 简述 css 中 position 的值
在 CSS 中，`position` 属性用于指定元素的定位方式。`position` 属性有以下几个常见的取值：

1. **static**：
   - 默认值，元素遵循正常的文档流布局，不受 `top`、`right`、`bottom` 和 `left` 属性的影响。

2. **relative**：
   - 元素相对于其自身在文档流中的位置进行定位，可以通过 `top`、`right`、`bottom` 和 `left` 属性进行微调，但不会影响其他元素的布局。

3. **absolute**：
   - 元素脱离文档流，相对于其最近的已定位祖先元素（非 `static`）进行定位，如果没有已定位的祖先元素，则相对于初始包含块（一般是 `<html>` 元素）进行定位。

4. **fixed**：
   - 元素脱离文档流，相对于浏览器窗口进行定位，即使页面滚动，元素也会固定在窗口的相同位置。

5. **sticky**：
   - 元素根据用户滚动的位置在父元素内定位，直到到达指定的偏移位置，然后固定在该位置。

6. **inherit**：
   - 继承父元素的 `position` 属性的值。

每种 `position` 值都有其特定的定位方式，可以根据布局需求选择合适的值来控制元素的位置。配合 `top`、`right`、`bottom` 和 `left` 属性，可以更精确地控制元素的位置。

## rem、em、vw、vh 的值各是什么意思
在 CSS 中，`rem`、`em`、`vw` 和 `vh` 是用于指定长度单位的常见值，它们各自代表不同的含义：

1. **rem**（root em）：
   - `rem` 单位是相对于根元素（`<html>` 元素）的字体大小的倍数。如果根元素的字体大小为 16px，`1rem` 就等于 16px。这使得 `rem` 单位在响应式设计中非常有用，因为它们相对于根元素的大小而不是父元素的大小。

2. **em**：
   - `em` 单位是相对于元素自身字体大小的倍数。例如，如果一个元素的字体大小为 16px，`1em` 就等于 16px。如果应用在嵌套元素中，`em` 单位将基于父元素的字体大小。

3. **vw**（viewport width）：
   - `vw` 单位表示视口宽度的百分比，`1vw` 等于视口宽度的 1%。例如，如果视口宽度为 1000px，`1vw` 就等于 10px。

4. **vh**（viewport height）：
   - `vh` 单位表示视口高度的百分比，`1vh` 等于视口高度的 1%。例如，如果视口高度为 800px，`1vh` 就等于 8px。

这些单位可帮助开发者创建更具有弹性和响应性的布局，使得元素的大小能够根据不同设备和视口大小进行调整。根据具体的设计需求和布局情况，选择合适的单位可以更好地控制元素的尺寸和布局。

## line-height 的值分别取 [2, 2em, 200%] 有什么区别?
在 CSS 中，`line-height` 属性用于设置行高，即行框（line box）的高度。当给定不同的值时，`line-height` 的表现会有所不同：

1. **2**：
   - 表示行高为字体大小的两倍。例如，如果字体大小为 16px，那么行高将会是 32px。

2. **2em**：
   - 表示行高为当前元素字体大小的两倍。如果当前元素的字体大小为 16px，那么行高将会是 32px。与前一种情况不同的是，`2em` 是相对于当前元素字体大小的倍数，而不是根据父元素或全局字体大小计算的。

3. **200%**：
   - 表示行高为当前元素字体大小的 200%。如果当前元素的字体大小为 16px，那么行高将会是 32px。与 `2em` 的效果相同，都是相对于当前元素字体大小计算的。

总的来说，无论是 `2`、`2em` 还是 `200%`，它们都表示行高是当前元素字体大小的倍数。区别在于 `2` 是绝对值，表示具体的像素值；而 `2em` 和 `200%` 是相对值，会根据当前元素的字体大小来计算实际的行高。

在 CSS 中，`line-height` 属性的继承行为与其具体取值有关。对于值为 `2`、`2em` 和 `200%` 的 `line-height` 属性，它们在继承方面的表现会有一些区别：

1. **值为 `2`**：
   - 当 `line-height` 的值为绝对长度（如 `px`）时，其继承性较低。通常情况下，绝对长度的 `line-height` 不会被子元素继承，子元素会使用其默认的行高值（通常是由字体大小决定的）。
  
2. **值为 `2em`**：
   - 当 `line-height` 的值为相对长度（如 `em`）时，其继承性会比绝对长度高一些。相对长度的 `line-height` 可能会被子元素继承，子元素会基于自身的字体大小计算行高，从而继承父元素的行高。

3. **值为 `200%`**：
   - 类似于相对长度的情况，百分比值的 `line-height` 也具有一定的继承性。子元素可能会继承父元素的行高，但具体效果取决于子元素自身的字体大小以及其他样式属性。

总的来说，相对长度（如 `em` 和 `%`）的 `line-height` 更有可能被子元素继承，因为它们相对于父元素的字体大小而言。而绝对长度的 `line-height` 则通常不会被继承，子元素会使用自己的默认行高。在实际应用中，需要根据具体情况来选择合适的 `line-height` 值以及考虑其继承性。

## Javascript 数组中有那些方法可以改变自身，那些不可以 详细说明
JavaScript 中的数组方法可以分为两类：会改变原始数组的方法和不会改变原始数组的方法。

### 会改变原始数组的方法：
1. **push()**：
   - 将一个或多个元素添加到数组的末尾，并返回新的长度。

2. **pop()**：
   - 删除数组的最后一个元素，并返回该元素的值。

3. **shift()**：
   - 删除数组的第一个元素，并返回该元素的值，同时将数组的长度减 1。

4. **unshift()**：
   - 将一个或多个元素添加到数组的开头，并返回新的长度。

5. **splice()**：
   - 通过删除或替换现有元素或者添加新元素来修改数组。

6. **reverse()**：
   - 颠倒数组中元素的顺序，会改变原数组。

7. **sort()**：
   - 对数组元素进行排序，会改变原数组。

8. **fill()**：
   - 用静态值填充数组的所有元素，可以指定填充的起始位置和结束位置。

### 不会改变原始数组的方法：
1. **concat()**：
   - 用于合并两个或多个数组，但不会改变现有数组，而是返回一个新数组。

2. **slice()**：
   - 返回数组的一部分，但不会改变原数组。

3. **filter()**：
   - 创建一个新数组，其中包含通过所提供函数实现的测试的所有元素。

4. **map()**：
   - 创建一个新数组，其结果是该数组中的每个元素调用一个提供的函数后返回的结果。

5. **forEach()**：
   - 对数组的每个元素执行一次提供的函数，但不会改变原数组。

6. **join()**：
   - 将数组中的所有元素连接成一个字符串，不会改变原数组。

7. **indexOf()** 和 **lastIndexOf()**：
   - 返回指定元素在数组中第一次/最后一次出现的位置，不会改变原数组。

这些方法的区别在于它们是否会改变原始数组。在选择使用这些方法时，需要根据具体的需求和场景来决定使用哪种方法。

## 如何判断一个数组是否包含某个值
在 JavaScript 中，可以使用以下方法来判断一个数组是否包含某个特定的值：

1. **indexOf() 方法**：
   - `indexOf()` 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在则返回 -1。可以通过检查返回值是否大于等于 0 来确定数组是否包含该值。
   
   ```javascript
   const array = [1, 2, 3, 4, 5];
   const value = 3;
   
   if (array.indexOf(value) >= 0) {
       console.log("数组包含值 " + value);
   } else {
       console.log("数组不包含值 " + value);
   }
   ```

2. **includes() 方法**：
   - `includes()` 方法用于判断一个数组是否包含一个指定的值，返回一个布尔值。如果数组包含该值，则返回 `true`；否则返回 `false`。
   
   ```javascript
   const array = [1, 2, 3, 4, 5];
   const value = 3;
   
   if (array.includes(value)) {
       console.log("数组包含值 " + value);
   } else {
       console.log("数组不包含值 " + value);
   }
   ```

这两种方法都可以用来判断数组中是否包含某个特定的值，选择其中一种方法取决于个人偏好和代码的清晰度。

## 如何判断字符串包含某个子串
在 JavaScript 中，可以使用以下方法来判断一个字符串是否包含某个子串：

1. **includes() 方法**：
   - `includes()` 方法用于判断一个字符串是否包含另一个指定的字符串，返回一个布尔值。如果字符串包含该子串，则返回 `true`；否则返回 `false`。
   
   ```javascript
   const str = "Hello, World!";
   const subStr = "Hello";
   
   if (str.includes(subStr)) {
       console.log("字符串包含子串 " + subStr);
   } else {
       console.log("字符串不包含子串 " + subStr);
   }
   ```

2. **indexOf() 方法**：
   - `indexOf()` 方法返回调用它的 String 对象中第一次出现的指定值的索引，如果没有找到该值，则返回 -1。可以通过检查返回值是否大于等于 0 来确定字符串是否包含该子串。
   
   ```javascript
   const str = "Hello, World!";
   const subStr = "Hello";
   
   if (str.indexOf(subStr) >= 0) {
       console.log("字符串包含子串 " + subStr);
   } else {
       console.log("字符串不包含子串 " + subStr);
   }
   ```

这两种方法都可以用来判断一个字符串是否包含某个子串，选择其中一种方法取决于个人偏好和代码的清晰度。

## DOM 中如何阻止事件默认行为，如何判断事件否可阻止？
在 DOM 中，可以通过以下方式阻止事件的默认行为：

1. **阻止默认行为**：
   - 使用 `event.preventDefault()` 方法可以阻止事件的默认行为。这个方法通常在事件处理程序中调用。
   
   ```javascript
   // 阻止链接的默认跳转行为
   document.getElementById("myLink").addEventListener("click", function(event) {
       event.preventDefault();
   });
   ```

2. **判断事件是否可阻止**：
   - 有些事件是可以被阻止的，而有些则不可以。可以通过事件对象的 `cancelable` 属性来判断事件是否可以被阻止。
   
   ```javascript
   document.getElementById("myElement").addEventListener("click", function(event) {
       if (event.cancelable) {
           event.preventDefault();
           console.log("事件可以被阻止");
       } else {
           console.log("事件不可被阻止");
       }
   });
   ```

在上面的代码中，当事件可被阻止时，调用 `preventDefault()` 方法来阻止事件的默认行为，并输出相应的信息。当事件不可被阻止时，只输出事件不可被阻止的信息。

这样，你可以利用 `preventDefault()` 方法来阻止事件的默认行为，并通过 `cancelable` 属性来判断事件是否可以被阻止。

## 什么是事件冒泡和事件捕获
在 DOM 中，事件冒泡和事件捕获是描述事件传播方式的两种模型。

1. **事件冒泡（Event Bubbling）**：
   - 在事件冒泡模型中，当一个元素上的事件被触发时，这个事件会首先在最内层的元素上触发，然后逐级向上传播至最外层的祖先元素。
   - 举个例子，如果你在一个按钮上点击，该按钮的点击事件被触发，然后该事件会向上传播至按钮的父元素，再传播至更上层的祖先元素。

2. **事件捕获（Event Capturing）**：
   - 与事件冒泡相反，事件捕获模型中，事件从最外层的祖先元素开始传播，逐级向下直至最内层的元素，然后才触发在目标元素上的事件。
   - 举个例子，如果你在一个按钮上点击，事件会首先在最外层的祖先元素上触发，然后逐级向下传播至按钮所在的位置，最终触发按钮上的点击事件。

在实际开发中，事件冒泡和事件捕获都可以用来处理事件传播过程中的行为。在使用 `addEventListener` 绑定事件处理程序时，可以通过第三个参数来指定使用事件捕获还是事件冒泡，例如：

```javascript
element.addEventListener('click', myFunction, true); // 使用事件捕获
element.addEventListener('click', myFunction, false); // 使用事件冒泡
```

默认情况下，`addEventListener` 使用事件冒泡模型。事件冒泡和事件捕获可以在处理事件传播时提供更多的灵活性和控制。

## 什么是事件委托，e.currentTarget 与 e.target 有何区别
事件委托（Event delegation）是一种利用事件冒泡的机制，将事件处理程序绑定到一个父元素上，以代替将事件处理程序直接绑定到子元素上的技术。通过事件委托，可以减少事件处理程序的数量，提高性能，并且可以处理动态生成的子元素。

在事件处理程序中，`e.currentTarget` 和 `e.target` 是事件对象中的两个属性，它们在事件委托中起着重要的作用：

1. **e.currentTarget**：
   - `e.currentTarget` 表示当前正在处理事件的元素，即事件绑定的元素，不会随着事件的冒泡而改变。
   - 在事件委托中，通常会将事件处理程序绑定到父元素上，而 `e.currentTarget` 就会指向这个父元素。

2. **e.target**：
   - `e.target` 表示触发事件的实际目标元素，即事件最初发生的地方。在事件冒泡过程中，`e.target` 可能会改变，但最终会指向触发事件的元素。
   - 在事件委托中，通过检查 `e.target` 可以确定事件是由哪个子元素触发的，从而采取相应的处理。

举个例子，假设有一个父元素包含多个子元素，我们希望点击任何一个子元素时都能触发相同的事件处理程序。这时，可以将事件处理程序绑定到父元素上，并在事件处理程序中使用事件委托来判断是哪个子元素触发了事件，如下所示：

```javascript
document.getElementById('parentElement').addEventListener('click', function(e) {
    if (e.target.tagName === 'LI') {
        console.log('点击了子元素：' + e.target.textContent);
    }
});
```

在上面的例子中，当点击父元素下的任何一个子元素时，事件会冒泡至父元素，父元素上的事件处理程序会根据 `e.target` 判断是哪个子元素触发了事件，并进行相应的处理。这就是事件委托的基本原理。

## DOM 中 Element 与 Node 有何区别
在 DOM（文档对象模型）中，Element 和 Node 是两个重要的接口，它们之间有一些区别：

1. **Node**：
   - Node 接口表示 DOM 中的一个节点，可以是文档中的任何部分，包括元素、文本、注释等。Node 接口是所有 DOM 节点的基类，它定义了所有节点共有的属性和方法。
   - Node 接口有一些常用的属性，如 `nodeName`、`nodeType`、`nodeValue`，以及方法如 `appendChild()`、`removeChild()` 等。
   - 所有 DOM 元素、文本节点、注释节点等都是 Node 对象。

2. **Element**：
   - Element 接口表示 DOM 中的一个元素节点，即 HTML 中的标签元素，如 `<div>`、`<p>`、`<span>` 等。
   - Element 接口继承自 Node 接口，因此 Element 对象拥有 Node 接口定义的所有属性和方法，同时还有一些针对元素节点的特定属性和方法，如 `id`、`className`、`style`、`getAttribute()`、`setAttribute()` 等。
   - 所有 HTML 元素都是 Element 对象，它们是 Node 对象的一种特殊类型。

总的来说，Node 是 DOM 中所有节点的基类，包括元素节点（Element）、文本节点（Text）、注释节点（Comment）等；而 Element 是 Node 的一个子类，表示 HTML 文档中的元素节点。因此，所有 Element 都是 Node，但不是所有 Node 都是 Element。

## 详细描述一下 Object.defineProperty
`Object.defineProperty` 是 JavaScript 中用于定义或修改对象属性的方法。它允许精确地添加或修改对象的属性，并且可以控制属性的特性（如可枚举、可写、可配置等）。

### 语法
```javascript
Object.defineProperty(obj, prop, descriptor)
```

- `obj`：要定义属性的对象。
- `prop`：要定义或修改的属性的名称。
- `descriptor`：描述符对象，用于定义或修改属性的特性。

### 描述符对象（Descriptor Object）
描述符对象是一个普通的 JavaScript 对象，用于指定要定义或修改的属性的特性。它可以包含以下属性：

- `value`：属性的值，默认为 `undefined`。
- `writable`：属性的值是否可写，默认为 `false`。
- `enumerable`：属性是否可枚举，默认为 `false`。
- `configurable`：属性是否可配置，默认为 `false`。

### 示例
```javascript
let obj = {};

// 定义属性 'x'，值为 10，可写，可枚举，可配置
Object.defineProperty(obj, 'x', {
  value: 10,
  writable: true,
  enumerable: true,
  configurable: true
});

// 修改属性 'x' 的特性
Object.defineProperty(obj, 'x', {
  writable: false
});

// 定义属性 'y'，值为 20，不可写，不可枚举，不可配置
Object.defineProperty(obj, 'y', {
  value: 20,
  writable: false,
  enumerable: false,
  configurable: false
});
```

### 特性说明
- 当属性的特性为 `false` 时，表示该特性不可更改。例如，一旦将属性的 `configurable` 特性设置为 `false`，则不能再将其改为 `true`。
- 如果不指定特性，默认值为 `false`。

`Object.defineProperty` 提供了对对象属性更加精细的控制，可以定义属性的可写性、可枚举性和可配置性，从而实现对属性的更精细的管理。

## Object.keys 与 Object.getOwnPropertyNames() 有何区别
`Object.keys()` 和 `Object.getOwnPropertyNames()` 都是 JavaScript 中用于获取对象自身属性的方法，它们之间的区别在于返回的属性集合不同。

1. **Object.keys()**：
   - `Object.keys()` 方法返回一个由对象的可枚举属性组成的数组。
   - 只返回对象自身的可枚举属性，不包括不可枚举属性和原型链上的属性。
   - 示例：
   
   ```javascript
   const obj = {
     a: 1,
     b: 2,
     c: 3
   };
   
   console.log(Object.keys(obj)); // 输出 ["a", "b", "c"]
   ```

2. **Object.getOwnPropertyNames()**：
   - `Object.getOwnPropertyNames()` 方法返回一个由对象的所有自身属性组成的数组，包括可枚举和不可枚举属性。
   - 返回对象自身的所有属性，不包括原型链上的属性。
   - 示例：
   
   ```javascript
   const obj = {
     a: 1,
     b: 2,
     c: 3
   };
   
   console.log(Object.getOwnPropertyNames(obj)); // 输出 ["a", "b", "c"]
   ```

总结来说，`Object.keys()` 返回对象的可枚举属性数组，而 `Object.getOwnPropertyNames()` 返回对象的所有自身属性数组，包括可枚举和不可枚举属性。如果只需要获取对象的可枚举属性，可以使用 `Object.keys()`；如果需要获取对象的所有自身属性，包括可枚举和不可枚举属性，可以使用 `Object.getOwnPropertyNames()`。

## sessionStorage与localStorage有何区别

`sessionStorage` 和 `localStorage` 都是 Web Storage API 的一部分，用于在用户的浏览器会话中存储键值对。尽管它们都可以用来存储数据，但它们在存储持久性和生命周期方面存在一些关键区别：

### 1. 存储持久性
- **localStorage**：存储的数据是持久的，即使关闭浏览器，数据也不会丢失，直到明确地被清除。
- **sessionStorage**：存储的数据仅在当前会话中有效。当用户关闭浏览器窗口或标签页时，存储的数据会被自动清除。

### 2. 生命周期
- **localStorage**：数据在页面或浏览器关闭后仍然存在，直到你手动删除它们。
- **sessionStorage**：数据仅在当前会话中存在，一旦会话结束（例如，关闭浏览器窗口或标签页），数据就会被清除。

### 3. 使用场景
- **localStorage**：适用于需要跨多个页面或会话访问的数据，如用户的偏好设置或配置信息。
- **sessionStorage**：适用于存储与当前会话相关的数据，如用户的登录状态或一次性会话信息。

### 4. 命名空间
- **localStorage**：全局命名空间，意味着任何页面都可以访问存储在 `localStorage` 中的数据。
- **sessionStorage**：会话命名空间，意味着存储的数据仅限于创建它的页面或标签页，其他页面或标签页无法访问。

### 5. 方法
- 两者都提供了相同的方法来设置和获取数据，如 `setItem(key, value)` 和 `getItem(key)`，以及 `removeItem(key)` 和 `clear()` 来清除数据。

### 示例
以下是一个简单的示例，展示了如何使用 `localStorage` 和 `sessionStorage`：

```javascript
// 使用 localStorage 存储数据
localStorage.setItem('key', 'value');
console.log(localStorage.getItem('key')); // 输出 'value'

// 使用 sessionStorage 存储数据
sessionStorage.setItem('sessionKey', 'sessionValue');
console.log(sessionStorage.getItem('sessionKey')); // 输出 'sessionValue'

// 当关闭浏览器或标签页时，sessionStorage 的数据会被清除，而 localStorage 的数据仍然存在
```

总结来说，`localStorage` 和 `sessionStorage` 都是为了在客户端存储数据而设计的，但它们在数据的持久性和生命周期方面有所不同，应根据具体的应用场景选择使用。

## 如何封装一个支持过期时间的 localStorage
可以封装一个支持过期时间的 `localStorage`，可以通过以下步骤实现：

1. 创建一个 `Storage` 类，定义 `get()`, `set()`, `remove()` 和 `clear()` 方法。
2. 在 `set()` 方法中，为每个键值对添加一个过期时间，并将其存储在 `localStorage` 中。
3. 在 `get()` 方法中，检查每个键值对的过期时间，如果已过期，则从 `localStorage` 中删除该键值对并返回 `null`。
4. 在 `remove()` 方法中，删除指定键的值和过期时间。
5. 在 `clear()` 方法中，删除所有键值对和过期时间。

以下是一个示例实现：

```javascript
class Storage {
  constructor() {
    this.storage = window.localStorage;
  }

  get(key) {
    const item = JSON.parse(this.storage.getItem(key));
    if (!item) {
      return null;
    }
    if (Date.now() > item.expires) {
      this.remove(key);
      return null;
    }
    return item.value;
  }

  set(key, value, expires) {
    const item = {
      value,
      expires: expires ? Date.now() + expires : Infinity,
    };
    this.storage.setItem(key, JSON.stringify(item));
  }

  remove(key) {
    this.storage.removeItem(key);
  }

  clear() {
    this.storage.clear();
  }
}
```

使用示例：

```javascript
const storage = new Storage();
storage.set('key', 'value', 1000); // 存储一个过期时间为 1 秒的键值对
console.log(storage.get('key')); // 输出 'value'
setTimeout(() => {
  console.log(storage.get('key')); // 输出 null，因为键值对已过期
}, 2000);
```

在上面的示例中，我们创建了一个 `Storage` 类，它具有 `get()`, `set()`, `remove()` 和 `clear()` 方法。在 `set()` 方法中，我们将每个键值对的过期时间存储在 `localStorage` 中，并在 `get()` 方法中检查过期时间并删除过期的键值对。这样，我们就可以创建一个支持过期时间的 `localStorage`。

## 如何统计当前页面出现的所有标签
要统计当前页面中出现的所有标签，你可以使用 JavaScript 来实现。以下是一种可能的方法：

```javascript
// 获取当前页面中出现的所有标签
function countTags() {
    const tags = {};
    const allTags = document.querySelectorAll('*');

    allTags.forEach(tag => {
        const tagName = tag.tagName.toLowerCase();
        if (tags[tagName]) {
            tags[tagName] += 1;
        } else {
            tags[tagName] = 1;
        }
    });

    return tags;
}

// 统计当前页面中出现的所有标签
const tagsCount = countTags();
console.log(tagsCount);
```

在这段代码中，`countTags()` 函数会遍历当前页面中的所有元素，并统计每种标签出现的次数。它会返回一个对象，其中键是标签名，值是该标签在页面中出现的次数。

你可以将这段代码添加到你的页面中的 `<script>` 标签中，或者在浏览器的开发者工具控制台中执行这段代码来查看当前页面中出现的所有标签及其数量。

请注意，这段代码只会统计 HTML 标签，不会考虑 CSS 选择器、JavaScript 生成的元素或其他非标签元素。如果需要进一步的筛选或统计其他类型的元素，可以根据具体需求进行适当的修改。

## 如何监听 localStorage 的变动

要监听 `localStorage` 的变动，可以使用 `window` 对象上的 `storage` 事件。这个事件会在 `localStorage` 中的数据发生变化时被触发。以下是如何实现监听 `localStorage` 变动的示例代码：

```javascript
// 监听localStorage的变化
window.addEventListener('storage', function(event) {
    console.log('LocalStorage changed:', event.key, event.newValue, event.oldValue, event.url);

    // event.key 是被变更的键名
    // event.newValue 是新值，如果不存在则为 null
    // event.oldValue 是旧值，如果不存在则为 null
    // event.url 是触发这个事件的页面的 URL
});

// 示例：设置localStorage
localStorage.setItem('testKey', 'testValue');

// 示例：删除localStorage中的键
localStorage.removeItem('testKey');
```

在这段代码中，我们为 `window` 对象添加了一个事件监听器，监听 `storage` 事件。当 `localStorage` 中的数据发生变化时（无论是添加、修改还是删除键值对），都会触发这个事件。

请注意以下几点：

1. `storage` 事件不会在触发它的页面中触发，而是在所有打开的页面中触发。这意味着，如果你在一个页面上修改了 `localStorage`，所有打开的页面都会接收到 `storage` 事件。

2. 由于安全原因，`storage` 事件不会在跨源（cross-origin）的情况下触发。也就是说，如果两个页面不在同一个源上，那么一个页面上的 `localStorage` 变化不会在另一个页面上触发 `storage` 事件。

3. `storage` 事件不会在 `localStorage` 的 `key` 或 `value` 被修改时立即触发，而是在页面重新加载或触发 `storage` 事件时才触发。

使用 `storage` 事件时，请确保你的代码能够处理这些情况，并适当处理事件中的信息。