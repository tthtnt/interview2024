## vue 中 v-if 和 v-show 的区别是什么
在 Vue 中，`v-if` 和 `v-show` 都是用来控制元素显示或隐藏的指令，但它们之间有一些区别：

- `v-if` 指令是惰性的，它只在条件为真时才会渲染元素，也就是说如果条件为假则不会渲染该元素，而且如果条件从假变为真，它会重新创建该元素及其子元素。因此，`v-if` 更适合在条件不经常改变的情况下使用。

- `v-show` 指令是立即渲染的，它会在页面初始渲染时就被渲染出来，只是通过 CSS 样式来控制元素的显示或隐藏。因此，如果元素在页面中需要频繁显示和隐藏，使用 `v-show` 会比 `v-if` 更加高效。

总的来说，如果您需要在页面中频繁地显示和隐藏元素，使用 `v-show` 会比 `v-if` 更加高效，因为它避免了重新渲染的开销。但如果您需要在条件不经常改变的情况下显示或隐藏元素，使用 `v-if` 会更加合适，因为它可以避免不必要的 DOM 渲染。

## vue 中 computed 的原理是什么
在 Vue 中，`computed` 属性用于计算衍生数据，它的原理是基于其依赖的响应式数据进行缓存，只有在依赖数据发生变化时才会重新计算，从而提高性能。

当您定义一个 `computed` 属性时，Vue 会在内部创建一个计算属性，并自动追踪该属性所依赖的响应式数据。当这些依赖数据发生变化时，Vue 将会重新计算该计算属性的值。但如果依赖数据没有发生变化，Vue 将会返回之前缓存的计算属性值，而不会重新计算。

这种机制使得 `computed` 属性在模板中使用时，就像是一个响应式的属性一样，但实际上是根据依赖数据动态计算得到的。

总结一下，`computed` 的原理可以归纳为以下几点：
1. Vue会自动追踪`computed`属性所依赖的响应式数据。
2. 当依赖数据发生变化时，Vue会重新计算`computed`属性的值。
3. 如果依赖数据没有发生变化，Vue会返回之前缓存的计算属性值，避免不必要的重复计算。
4. 在模板中使用`computed`属性时，就像是使用普通属性一样，但实际上是根据依赖数据动态计算得到的。

## vue-loader 的实现原理是什么
`vue-loader` 是一个用于处理 Vue 单文件组件（.vue 文件）的 webpack loader。它的主要作用是将 Vue 单文件组件中的模板、脚本和样式部分分离出来，并转换为 JavaScript 模块，以便在浏览器中运行。

以下是 `vue-loader` 的主要实现原理：

1. **解析单文件组件**：`vue-loader` 首先会解析 Vue 单文件组件，识别出其中的 `<template>`（模板部分）、`<script>`（脚本部分）和 `<style>`（样式部分）。

2. **处理模板**：`vue-loader` 使用相应的编译器（如 `vue-template-compiler`）来编译模板部分，将模板转换为可执行的渲染函数。

3. **处理脚本**：`vue-loader` 会对脚本部分进行处理，根据配置选择是否进行代码转译（如使用 Babel 进行 ES6+ 转换）以及是否进行代码检查（如使用 ESLint 进行代码规范检查）。

4. **处理样式**：`vue-loader` 会处理样式部分，支持多种样式语言（如 CSS、SCSS、Less 等），并根据配置选择是否进行 CSS 预处理器的转换。

5. **生成组件描述**：最后，`vue-loader` 将处理后的模板、脚本和样式组合在一起，生成一个 JavaScript 模块，该模块包含了 Vue 组件的描述信息，可以被 webpack 打包并最终在浏览器中运行。

通过以上步骤，`vue-loader` 实现了将 Vue 单文件组件转换为可在浏览器中运行的 JavaScript 模块的功能。这样做的好处是能够充分利用 webpack 的打包能力，实现了模块化开发和更高效的前端构建流程。

## react 中 ref 是干什么用的，有哪些使用场景
在 React 中，`ref` 是用来获取对 DOM 元素或 React 组件实例的引用的特殊属性。通过 `ref`，您可以在 React 组件中访问、操作以及修改 DOM 元素或组件实例。

以下是一些 `ref` 的常见使用场景：

1. **访问 DOM 元素**：通过 `ref` 可以获取对特定 DOM 元素的引用，从而可以直接操作该 DOM 元素，比如修改样式、获取尺寸、添加事件监听器等。

2. **表单处理**：在表单处理中，可以使用 `ref` 获取表单元素的引用，以便在需要时访问表单的值或执行表单验证。

3. **动画和过渡**：在动画和过渡效果中，可以使用 `ref` 获取元素的引用，从而在动画库中使用该引用来触发动画效果。

4. **集成第三方库**：有些第三方库可能需要直接操作 DOM 元素，通过 `ref` 可以将 React 组件和第三方库进行集成。

5. **焦点管理**：通过 `ref` 可以设置元素的焦点，比如在页面加载时自动将焦点设置在某个输入框上。

6. **访问子组件**：通过 `ref` 可以获取对子组件实例的引用，从而可以直接调用子组件的方法或访问其属性。

需要注意的是，尽量避免过度使用 `ref`，因为过多的 `ref` 可能会导致代码难以维护和理解。在大多数情况下，应该优先考虑使用 React 的状态和 props 来管理组件的状态和交互，只在必要的情况下才使用 `ref`。

## 如何使用 react/vue 实现一个 message API
实现一个 Message API 可以让你在 React 或 Vue 应用中方便地显示消息通知、警告或成功提示。下面是一个简单的实现思路：

### React 实现：

1. **创建 Message 组件：**
   创建一个 Message 组件，用于显示消息内容。这个组件可以接受消息内容和类型作为 props。

2. **使用 Context 管理消息状态：**
   使用 React Context 来管理消息状态，包括消息内容、类型等。在根组件中创建一个 Context Provider，用于提供消息状态给整个应用。

3. **暴露 API 方法：**
   在 Context 中定义一个方法，比如 `showMessage(message, type)`，用于在其他组件中调用以显示消息。

4. **在需要显示消息的组件中调用 API 方法：**
   在需要显示消息的组件中，通过 Context 调用 `showMessage` 方法，传入消息内容和类型。

### Vue 实现：

1. **创建 Message 组件：**
   创建一个 Message 组件，用于显示消息内容。这个组件可以接受消息内容和类型作为 props。

2. **使用 EventBus 或 Vuex 管理消息状态：**
   - **EventBus：** 可以使用 Vue 的 EventBus 作为事件中心，用于在组件间传递消息显示请求。
   - **Vuex：** 如果应用中已经使用 Vuex，可以在 Vuex 中管理消息状态，并在需要显示消息时提交 mutation。

3. **暴露 API 方法：**
   在 EventBus 或 Vuex 中定义一个方法，比如 `showMessage(message, type)`，用于在其他组件中调用以显示消息。

4. **在需要显示消息的组件中调用 API 方法：**
   在需要显示消息的组件中，通过 EventBus 或 Vuex 调用 `showMessage` 方法，传入消息内容和类型。

### 总结：

以上是一个简单的实现思路，你可以根据实际需求和应用复杂度进行调整和优化。在实际项目中，你可能会需要更多的功能，比如自动消失的消息、不同类型的消息样式、消息队列处理等。这样的消息组件可以提高用户体验，让用户更容易地接收到重要信息。

## 有没有用 npm 发布过 package，如何发布
以下是用 npm 发布包的基本步骤：

1. **注册 npm 账号：**
   如果你还没有 npm 账号，你需要先在 [npm官网](https://www.npmjs.com/) 注册一个。

2. **创建包：**
   - 在本地创建一个新的文件夹，用于存放你的包。
   - 在该文件夹中，创建一个 `package.json` 文件，这将是你的包的描述文件。

3. **编写代码：**
   - 在包的文件夹中，编写你的代码。

4. **编写 `package.json`：**
   - 包名（`name`）必须是唯一的，不能与现有包冲突。
   - 描述（`description`）是对你的包的简要说明。
   - 主入口（`main`）是包的主要入口文件。
   - 版本（`version`）遵循语义化版本控制。

5. **测试包：**
   在发布前，确保你的包在本地测试通过。

6. **登录 npm：**
   打开命令行，运行以下命令来登录你的 npm 账号：
   ```sh
   npm login
   ```
   按照提示输入你的用户名、密码和邮箱。

7. **发布包：**
   发布包到 npm，使用以下命令：
   ```sh
   npm publish
   ```
   如果这是第一次发布，系统会要求你输入包名，然后会提示你选择一个 registry（通常是默认的 https://registry.npmjs.org/）。

8. **验证发布：**
   发布后，你可以通过以下命令检查你的包是否在 npm 上：
   ```sh
   npm view <你的包名>
   ```

请注意，发布到 npm 的包需要遵守其[使用条款](https://www.npmjs.com/package/terms)和[政策](https://www.npmjs.com/package/policies)。确保你的包不违反任何规定。此外，发布包之前，请确保你的代码和 `package.json` 文件中的信息都是最新和准确的。

## 手写一个koa
Koa 是一个基于 Node.js 的 Web 框架，它使用了 ES6 的特性，利用了 async/await 来简化异步流程的处理。下面是一个简单的手写 Koa 的示例，用于展示 Koa 的基本工作原理：

```javascript
class Koa {
  constructor() {
    this.middlewares = [];
  }

  use(middleware) {
    this.middlewares.push(middleware);
  }

  async handleRequest(ctx, middlewares) {
    const composedMiddleware = this.compose(middlewares);
    await composedMiddleware(ctx);
  }

  compose(middlewares) {
    return async (ctx) => {
      let index = -1;
      const dispatch = async (i) => {
        if (i <= index) {
          throw new Error('next() called multiple times');
        }
        index = i;
        const middleware = middlewares[i];
        if (i === middlewares.length) {
          middleware = async () => {};
        }
        if (!middleware) {
          return;
        }
        return middleware(ctx, () => dispatch(i + 1));
      };
      return dispatch(0);
    };
  }

  callback() {
    return async (req, res) => {
      const ctx = { req, res };
      try {
        await this.handleRequest(ctx, this.middlewares);
        res.end(ctx.body);
      } catch (err) {
        console.error(err);
        res.statusCode = 500;
        res.end('Internal Server Error');
      }
    };
  }

  listen(port) {
    const http = require('http');
    const server = http.createServer(this.callback());
    server.listen(port, () => {
      console.log(`Server is running on port ${port}`);
    });
  }
}

// 创建一个 Koa 应用
const app = new Koa();

// 添加中间件示例
app.use(async (ctx, next) => {
  ctx.body = 'Hello, Koa!';
  await next();
});

// 启动服务器
app.listen(3000);
```

这个简单的示例展示了 Koa 的基本实现原理，包括中间件的处理、请求的处理、错误处理等。在实际的应用中，Koa 还提供了更多的功能和中间件，例如路由、静态文件服务、模板引擎等，你可以根据实际需求来扩展和定制你的 Koa 应用。

## https 是如何保证报文安全的
HTTPS（HyperText Transfer Protocol Secure）是一种通过加密和认证保护数据传输安全的通信协议。它通过使用 SSL（Secure Sockets Layer）或其后续的版本 TLS（Transport Layer Security）来加密通信内容，从而保证了报文的安全性。以下是 HTTPS 如何保证报文安全的主要方式：

1. **加密数据传输：**
   当客户端与服务器建立 HTTPS 连接时，它们之间的通信内容会被加密。这意味着即使有人拦截了通信，也无法直接读取或修改传输的数据。这种加密是通过使用公钥加密算法和对称密钥加密算法来实现的。

2. **身份认证：**
   服务器使用数字证书来证明自己的身份。数字证书由受信任的证书颁发机构（CA）签发，包含了服务器的公钥和相关信息。客户端可以使用这些证书来验证服务器的身份，确保其正在连接到预期的服务器，而不是一个恶意伪装的服务器。

3. **数据完整性：**
   HTTPS 使用消息摘要算法（如 SHA-256）来保证传输数据的完整性。在数据传输过程中，这些摘要会被用来验证数据是否被篡改。如果数据在传输过程中被修改，接收方会发现摘要与接收到的数据不匹配，从而知道数据已经被篡改。

4. **密钥交换：**
   HTTPS 使用公钥加密算法来安全地交换对称密钥，这样双方可以使用对称密钥进行加密和解密通信内容。这种方式可以防止中间人攻击（Man-in-the-middle attacks）。

总的来说，HTTPS 通过加密数据传输、身份认证、数据完整性验证和安全的密钥交换机制来保证通信的安全性。这使得敏感信息（如个人信息、银行卡信息等）在传输过程中得到保护，从而有效地防止了许多潜在的网络攻击。

## 我们如何从 http 的报文中得知该服务使用的技术栈
从 HTTP 报文中直接确定服务使用的技术栈是相对困难的，因为 HTTP 报文主要包含请求和响应的数据，而不包含服务端使用的具体技术栈信息。然而，有一些间接的方法可以帮助你推断服务端使用的技术栈：

1. **响应头中的 Server 字段：**
   有些 Web 服务器会在响应头中包含一个 `Server` 字段，用于指示服务器使用的软件和版本信息。例如，`Server: Apache/2.4.41 (Unix)` 表示服务器使用的是 Apache 软件，版本是 2.4.41。虽然这并不总是准确，但它可以给你一些线索。

2. **响应体中的特定标识：**
   有些 Web 框架或库会在生成的 HTML 或响应体中包含特定的标识，比如特定的 CSS 类名、JavaScript 函数名或注释等。通过这些标识，你可能可以推断出服务端使用的技术栈。

3. **错误页面信息：**
   当服务端返回错误页面时，有时会包含关于服务端技术栈的信息。例如，当出现 500 错误时，错误页面可能会包含关于服务器配置或使用的技术栈的信息。

4. **URL 结构和后缀：**
   有些 Web 框架会在 URL 结构中暴露出其使用的技术栈。例如，`.php` 后缀通常表示使用 PHP，`.aspx` 后缀表示使用 ASP.NET 等。

5. **响应头中的其他字段：**
   除了 `Server` 字段外，有时还可以通过其他响应头字段（如 `X-Powered-By`）来获取关于服务端使用的技术栈的信息。

尽管以上方法可能会提供一些线索，但并不是绝对准确的。有些服务端可能会隐藏具体的技术栈信息，或者使用定制的配置来混淆。因此，最可靠的方法是直接与网站所有者进行沟通，或者使用专门的工具来进行技术栈探测。

## 在发送 http 请求报文时，Host 是必要的吗
是的，在发送 HTTP 请求报文时，`Host` 头是必需的。根据 HTTP/1.1 协议规范，所有的 HTTP/1.1 请求都必须包含一个 `Host` 头。这个头部字段指定了请求的目标主机（服务器）的域名或 IP 地址。

在 HTTP/1.0 中，并没有要求包含 `Host` 头部字段，因为当时一个服务器通常只服务一个域名，所以可以根据连接的 IP 地址来确定目标主机。但是随着虚拟主机的普及，一个服务器可能会服务多个域名，因此在 HTTP/1.1 中引入了 `Host` 头部字段，以便服务器能够正确地处理请求。

如果在 HTTP/1.1 请求中没有包含 `Host` 头部字段，服务器会返回一个 400 Bad Request 错误响应，因为它无法确定请求要访问的是哪个主机。因此，为了确保请求被正确路由到目标服务器，发送 HTTP 请求时包含 `Host` 头部字段是必要的。

## http 响应头中如果 content-type 为 application/octet-stream，则代表什么意思
当 HTTP 响应头中的 `Content-Type` 字段的值为 `application/octet-stream` 时，它表示响应的内容是一个二进制流，即未知的二进制数据类型。这种 MIME 类型通常用于传输不具有明确定义的二进制数据，而不是特定的文本格式或媒体类型。

具体来说，`application/octet-stream` 表示响应的内容是未经过处理的二进制数据流，这意味着接收方应该将响应内容保存为一个二进制文件，而不应尝试解析它为文本或其他格式。

一些常见的用例包括传输文件下载、图像、音频、视频等二进制数据，或者在某些情况下，服务器可能不知道响应内容的确切类型，因此将其标记为 `application/octet-stream`。

总的来说，`application/octet-stream` 表示通用的二进制数据流，接收方应该以二进制形式处理响应内容，而不假设其具有特定的内容类型或格式。

## http 向 https 做重定向应该使用哪个状态码
当你想要将 HTTP 请求重定向到 HTTPS 地址时，应该使用状态码 301（永久重定向）或 302（临时重定向），具体取决于你的需求和情况。

1. **使用 301 永久重定向：**
   - 如果你打算永久将 HTTP 请求重定向到 HTTPS，你应该使用状态码 301。这告诉浏览器和搜索引擎，该重定向是永久性的，因此它们应该更新书签和索引以指向新的 HTTPS 地址。

   例如，当用户访问 `http://example.com` 时，服务器会返回状态码 301 并指示浏览器重定向到 `https://example.com`。这将告诉浏览器以后应该直接访问 HTTPS 地址。

2. **使用 302 临时重定向：**
   - 如果你只是暂时将 HTTP 请求重定向到 HTTPS，你应该使用状态码 302。这告诉浏览器，该重定向是临时性的，因此浏览器会记住原始的 HTTP 地址。

   例如，当用户访问 `http://example.com` 时，服务器返回状态码 302 并指示浏览器暂时重定向到 `https://example.com`。浏览器会记住原始的 HTTP 地址，以便以后再次访问。

在实践中，大多数情况下建议使用 301 永久重定向，因为这有助于搜索引擎优化（SEO）和确保用户访问安全的 HTTPS 网站。但如果你只想暂时重定向，可以使用 302 临时重定向。

## js 代码压缩 minify 的原理是什么
JavaScript 代码压缩（minification）的原理是通过删除代码中的无用字符和空格，来减小文件大小，从而提高页面加载速度和响应时间。

具体来说，JavaScript 压缩器通常会执行以下操作：

1. **删除注释：** 压缩器会删除 JavaScript 代码中的注释，因为注释在运行时不会对代码的执行产生任何影响。

2. **删除空格和换行符：** 压缩器会删除 JavaScript 代码中的空格和换行符，因为它们在运行时也不会对代码的执行产生任何影响。这样可以将代码压缩到一行或几行，从而减小文件大小。

3. **简化变量名：** 压缩器会将长变量名替换为短变量名，从而减小文件大小。这样做不会影响代码的执行，因为变量名只是用来标识变量的标签，而不影响变量的值或行为。

4. **删除无用代码：** 压缩器会删除 JavaScript 代码中未被使用的变量、函数和代码块，从而减小文件大小。这样做可以提高代码的可读性和维护性，同时减少文件大小，加快页面加载速度。

JavaScript 压缩器通常使用特定算法来执行上述操作，例如 UglifyJS、Closure Compiler 和 YUI Compressor 等。这些工具可以自动执行代码压缩和优化，从而减小文件大小，提高页面性能。

## 在 Node 应用中如何利用多核心CPU的优势

在 Node 应用中利用多核心 CPU 的优势通常涉及使用异步编程和适当的并发模型。以下是一些方法来利用 Node.js 的多核能力：

1. **使用 `cluster` 模块：**
   Node.js 的 `cluster` 模块允许你创建多个子进程（workers），这些子进程可以分布在不同的 CPU 核心上运行。每个子进程都可以独立地处理任务，从而实现并行处理。

   ```javascript
   const cluster = require('cluster');
   const numCPUs = require('os').cpus().length;

   if (cluster.isMaster) {
       console.log(`Master ${process.pid} is running`);

       // 衍生工作进程
       for (let i = 0; i < numCPUs; i++) {
           cluster.fork();
       }

       cluster.on('exit', (worker, code, signal) => {
           console.log(`worker ${worker.process.pid} died`);
       });
   } else {
       // 工作进程可以共享任何 TCP 连接
       // 在本例中，它是一个 HTTP 服务器
       require('http').createServer((req, res) => {
           res.writeHead(200);
           res.end('hello world\n');
       }).listen(8000);

       console.log(`Worker ${process.pid} started`);
   }
   ```

2. **使用 `worker_threads` 模块：**
   Node.js 12 及更高版本引入了 `worker_threads` 模块，允许你创建线程。使用线程可以在单个进程内实现并发，从而利用同一核心上的多线程。

   ```javascript
   const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');

   if (isMainThread) {
       const numCPUs = require('os').cpus().length;

       for (let i = 0; i < numCPUs; i++) {
           const worker = new Worker(__filename, { workerData: i });
           worker.on('message', (result) => {
               console.log(`Message received: ${result}`);
           });
       }
   } else {
       // 在工作线程中执行一些工作
       parentPort.postMessage(`Hello from worker ${workerData} on CPU ${process.pid}`);
   }
   ```

3. **使用异步 I/O：**
   Node.js 本身是异步非阻塞的，这本身就是利用多核 CPU 的一个关键方式。通过使用异步 I/O 操作，Node.js 可以在不阻塞事件循环的情况下，同时执行多个 I/O 操作，从而提高整体性能。

4. **负载均衡：**
   如果你有一个负载均衡器，你可以使用它来分配请求到不同的 Node.js 实例，这样每个实例都可以运行在单独的 CPU 核心上。

5. **避免共享状态：**
   在多进程或多线程环境中，避免共享状态可以减少锁和同步的需要，从而减少竞争条件，提高性能。

通过上述方法，你可以有效地利用 Node.js 的多核 CPU，提高应用的并发处理能力和响应速度。

## react hooks 中如何模拟 componentDidMount
在 React Hooks 中，可以使用 `useEffect` 钩子来模拟 `componentDidMount` 的行为。`useEffect` 钩子可以在组件挂载后执行一次，类似于 `componentDidMount` 方法。下面是一个示例：

```javascript
import React, { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // 在组件挂载后执行一次
    console.log('Component mounted');
    // 可以在这里执行一些副作用操作，比如获取数据、订阅事件等
    return () => {
      // 在组件卸载时执行一次
      console.log('Component unmounted');
      // 可以在这里清理一些副作用操作，比如取消订阅、清除定时器等
    };
  }, []); // 第二个参数为空数组，表示只在组件挂载时执行一次

  return <div>My Component</div>;
}
```

在上面的例子中，`useEffect` 钩子的第一个参数是一个回调函数，用来执行一些副作用操作。第二个参数是一个数组，用来指定依赖项。如果依赖项为空数组，那么这个副作用操作只会在组件挂载和卸载时执行一次，类似于 `componentDidMount` 和 `componentWillUnmount` 方法。如果依赖项不为空，那么这个副作用操作会在组件挂载后和每次依赖项发生变化时执行。

总的来说，使用 `useEffect` 钩子可以很方便地模拟 `componentDidMount` 方法的行为，并且可以在同一个钩子中处理组件的挂载和卸载逻辑。

## http 1.1 中的 keep-alive 有什么作用
在 HTTP 1.1 中，Keep-Alive 是一种持久连接机制，它允许在单个 TCP 连接上发送和接收多个 HTTP 请求和响应。这种机制的作用主要体现在以下几个方面：

1. **减少连接建立和断开的开销：** 在传统的 HTTP 1.0 中，每个 HTTP 请求都需要建立一个新的 TCP 连接，这会带来连接建立和断开的开销。使用 Keep-Alive 可以避免这种开销，因为在单个 TCP 连接上可以发送多个请求和接收多个响应。

2. **减少延迟：** TCP 连接的建立需要经过三次握手的过程，而使用 Keep-Alive 可以减少这种连接建立的延迟，因为可以重复使用已经建立的连接。

3. **减少资源占用：** 持久连接可以减少服务器和客户端上的资源占用，因为不需要频繁地创建和销毁连接。

4. **提高性能：** 通过减少连接建立和断开的开销以及减少延迟，Keep-Alive 可以提高 HTTP 请求的处理效率和性能。

总的来说，HTTP 1.1 中的 Keep-Alive 机制通过复用 TCP 连接，减少连接建立和断开的开销，从而提高了网络通信的效率和性能。这对于提升 Web 服务的响应速度和降低资源消耗都具有重要意义。

## 如果使用 SSR，可以在 created/componentWillMount 中访问 localStorage 吗
在使用服务器端渲染（SSR）时，是无法在 `created` 钩子（Vue.js）或 `componentWillMount` 生命周期钩子（React）中直接访问 `localStorage` 的。这是因为在服务器端渲染过程中，代码是在服务器上执行的，而 `localStorage` 是浏览器环境中的 API，服务器端没有直接访问 `localStorage` 的能力。

通常情况下，服务器端渲染是在服务器上生成 HTML，并将其发送给客户端，客户端再接管页面并运行 JavaScript 代码。因此，如果你需要在客户端代码中访问 `localStorage`，可以在组件挂载后（比如 `mounted` 钩子或 `componentDidMount` 生命周期钩子）进行访问。

在客户端代码中，可以这样访问 `localStorage`：

在 Vue.js 中：
```javascript
mounted() {
  const myData = localStorage.getItem('myData');
  // 在这里处理 localStorage 中的数据
}
```

在 React 中：
```javascript
componentDidMount() {
  const myData = localStorage.getItem('myData');
  // 在这里处理 localStorage 中的数据
}
```

这样可以确保在客户端渲染阶段访问 `localStorage`，而不会在服务器端渲染时出现问题。

## react hooks 如何替代 redux 功能
React Hooks 可以与 Context API 结合使用，来替代 Redux 的一些功能。虽然 Redux 在状态管理方面有其优势，但对于一些简单的应用场景，使用 React Hooks 和 Context API 可能更轻量和简洁。以下是一些使用 React Hooks 替代 Redux 功能的方法：

1. **useState：** `useState` 是 React 自带的状态管理钩子，可以用来管理组件内部的状态。对于一些简单的状态管理需求，可以使用 `useState` 替代 Redux。

2. **useReducer：** `useReducer` 是另一个 React 钩子，可以用来处理复杂的状态逻辑。它可以替代 Redux 中的 reducer 函数，用于处理状态的更新逻辑。

3. **Context API：** Context API 可以用来在 React 应用中共享全局的状态。通过创建一个全局的 Context 对象，可以在应用的任何地方访问和更新共享的状态。

4. **自定义 Hooks：** 可以编写自定义 Hooks 来封装复用逻辑。这样可以将状态管理逻辑抽象到自定义 Hook 中，使得组件更加简洁和可复用。

虽然 React Hooks 和 Context API 可以替代 Redux 的一些功能，但 Redux 仍然适用于大型应用或需要复杂状态管理的场景。Redux 提供了强大的工具和中间件来处理状态管理、副作用处理等方面的问题。因此，根据具体的应用场景和需求，可以选择适合的状态管理方案。

## 权限设计中的 RABC 是指什么
RABC 是基于角色的访问控制（Role-Based Access Control）的缩写。它是一种常见的访问控制模型，用于管理用户对系统资源的访问权限。

在 RABC 模型中，权限控制是基于角色的。每个用户被分配一个或多个角色，而每个角色都被授予特定的权限。用户通过角色来间接获取权限，而不是直接将权限授予用户。这种模型的核心概念是将权限与角色相关联，而不是将权限直接分配给用户。

RABC 模型的主要组成部分包括：

1. **角色（Role）：** 角色是一组权限的集合。它们可以代表用户的职责、职位或在系统中扮演的特定角色。例如，管理员、编辑、普通用户等都可以是角色。

2. **权限（Permission）：** 权限是指用户或角色在系统中执行某些操作的许可。这些操作可以包括读取、写入、更新或删除系统中的特定资源。

3. **用户（User）：** 用户是系统中的实体，可以被分配一个或多个角色。用户通过角色获得相应的权限。

RABC 模型的优点包括：

- **简化权限管理：** 通过将权限与角色相关联，可以简化权限管理。当用户的角色发生变化时，只需调整角色的权限，而不需要逐个调整用户的权限。

- **降低复杂性：** RABC 模型使得权限管理更加模块化和可维护，降低了系统的复杂性。

- **提高安全性：** 通过对角色进行权限控制，可以更好地管理和监控系统中的访问权限，提高系统的安全性。

总的来说，RABC 模型是一种常见的访问控制模型，它通过角色来管理用户的访问权限，为系统的权限管理提供了一种简洁而有效的解决方案。

## 什么是 CSRF 攻击
CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种常见的网络安全攻击，攻击者利用用户在已登录的情况下对受信任网站发起的请求来伪造用户的身份，执行未经用户授权的操作。

攻击原理如下：

1. **受害者登录受信任网站：** 攻击发生在用户已经登录了某个网站的情况下。用户在浏览器中保持了已登录状态，比如在一个选项卡中登录了银行网站。

2. **攻击者构造恶意请求：** 攻击者在另一个网站（恶意网站）中构造了一个恶意请求，这个请求会触发用户在受信任网站上执行某些操作，比如转账、更改密码等。

3. **诱使受信任网站执行恶意请求：** 攻击者诱使受信任网站上的用户（受害者）访问包含恶意请求的链接或页面。由于用户在受信任网站上保持了登录状态，浏览器会自动发送包含用户身份认证信息的请求，从而执行了恶意操作。

CSRF 攻击的危害包括但不限于：

- **未经授权的操作：** 攻击者可以以受害者的身份执行未经授权的操作，比如转账、更改密码等。

- **信息泄露：** 攻击者可以利用 CSRF 攻击获取用户的敏感信息，比如个人资料、银行账户信息等。

为了防范 CSRF 攻击，可以采取以下措施：

1. **使用 CSRF Token：** 在网站中使用 CSRF Token 可以防止 CSRF 攻击。服务器会生成一个随机的 Token，并将它嵌入到表单或请求中。提交请求时，服务器会验证 Token 的有效性，如果 Token 不匹配则拒绝请求。

2. **同源策略：** 浏览器的同源策略限制了一个网站在另一个网站上执行的操作。攻击者很难利用 CSRF 攻击跨域站点。

3. **使用验证码：** 对于敏感操作，可以要求用户输入验证码进行验证，增加安全性。

4. **限制敏感操作的访问权限：** 对于一些敏感操作，比如修改密码、转账等，应该要求用户重新输入密码或进行二次确认。

通过以上措施，可以有效地防范 CSRF 攻击，保护用户的账户安全和信息安全。

## 在 js 中如何把类数组转化为数组
在 JavaScript 中，类数组（array-like objects）是具有类似数组结构但并非真正的数组的对象，比如 `arguments` 对象或 DOM 元素集合。这些对象通常具有 `length` 属性和通过索引访问元素的能力，但不具备数组的方法（如 `push`、`pop` 等）。

如果你想将类数组对象转换为真正的数组，可以使用几种方法：

1. **Array.from() 方法：** `Array.from()` 方法可以从一个类数组或可迭代对象创建一个新的数组。例如：

```javascript
const arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
const array = Array.from(arrayLike);
console.log(array); // ['a', 'b', 'c']
```

2. **Array.prototype.slice.call() 方法：** 通过调用 `Array.prototype.slice.call()` 方法，可以将类数组对象转换为数组。例如：

```javascript
const arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
const array = Array.prototype.slice.call(arrayLike);
console.log(array); // ['a', 'b', 'c']
```

3. **Spread 操作符（...）：** 使用 ES6 中的 Spread 操作符也可以将类数组对象转换为数组。例如：

```javascript
const arrayLike = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
const array = [...arrayLike];
console.log(array); // ['a', 'b', 'c']
```

这些方法都可以将类数组对象转换为真正的数组，使你能够使用数组的方法和特性对其进行操作。

## Array(100).map(x => 1) 结果是多少
(100) [空属性 × 100]

Array.from(Array(100), (x) => 1); 和 Array(100).fill(1);才能生成100个1的数组[1,1,1.....]